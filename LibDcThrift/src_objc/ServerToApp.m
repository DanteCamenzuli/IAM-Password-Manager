/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

#import <Foundation/Foundation.h>

#import "TProtocol.h"
#import "TApplicationException.h"
#import "TProtocolException.h"
#import "TProtocolUtil.h"
#import "TProcessor.h"
#import "TObjective-C.h"
#import "TBase.h"
#import "TAsyncTransport.h"
#import "TProtocolFactory.h"
#import "TBaseClient.h"

#import "AppSystem.h"

#import "ServerToApp.h"


@implementation ServerToAppConstants
+ (void) initialize {
}
@end

@interface disconnect_args : NSObject <TBase, NSCoding> {
}

- (id) init;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

@end

@implementation disconnect_args

- (id) init
{
  self = [super init];
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[disconnect_args class]]) {
    return NO;
  }
  disconnect_args *other = (disconnect_args *)anObject;
  return YES;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"disconnect_args"];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"disconnect_args("];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface Disconnect_result : NSObject <TBase, NSCoding> {
  AppException * __ouch;

  BOOL __ouch_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=ouch, setter=setOuch:) AppException * ouch;
#endif

- (id) init;
- (id) initWithOuch: (AppException *) ouch;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (AppException *) ouch;
- (void) setOuch: (AppException *) ouch;
#endif
- (BOOL) ouchIsSet;

@end

@implementation Disconnect_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithOuch: (AppException *) ouch
{
  self = [super init];
  __ouch = [ouch retain_stub];
  __ouch_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"ouch"])
  {
    __ouch = [[decoder decodeObjectForKey: @"ouch"] retain_stub];
    __ouch_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__ouch_isset)
  {
    [encoder encodeObject: __ouch forKey: @"ouch"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __ouch_isset ? 2654435761 : 0;
  if (__ouch_isset)
  {
    hash = (hash * 31) ^ [__ouch hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[Disconnect_result class]]) {
    return NO;
  }
  Disconnect_result *other = (Disconnect_result *)anObject;
  if ((__ouch_isset != other->__ouch_isset) ||
      (__ouch_isset && ((__ouch || other->__ouch) && ![__ouch isEqual:other->__ouch]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__ouch release_stub];
  [super dealloc_stub];
}

- (AppException *) ouch {
  return [[__ouch retain_stub] autorelease_stub];
}

- (void) setOuch: (AppException *) ouch {
  [ouch retain_stub];
  [__ouch release_stub];
  __ouch = ouch;
  __ouch_isset = YES;
}

- (BOOL) ouchIsSet {
  return __ouch_isset;
}

- (void) unsetOuch {
  [__ouch release_stub];
  __ouch = nil;
  __ouch_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          AppException *fieldValue = [[AppException alloc] init];
          [fieldValue read: inProtocol];
          [self setOuch: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"Disconnect_result"];

  if (__ouch_isset) {
    if (__ouch != nil) {
      [outProtocol writeFieldBeginWithName: @"ouch" type: TType_STRUCT fieldID: 1];
      [__ouch write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"Disconnect_result("];
  [ms appendString: @"ouch:"];
  [ms appendFormat: @"%@", __ouch];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface sendMessage_args : NSObject <TBase, NSCoding> {
  AppMessage * __appMessage;

  BOOL __appMessage_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=appMessage, setter=setAppMessage:) AppMessage * appMessage;
#endif

- (id) init;
- (id) initWithAppMessage: (AppMessage *) appMessage;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (AppMessage *) appMessage;
- (void) setAppMessage: (AppMessage *) appMessage;
#endif
- (BOOL) appMessageIsSet;

@end

@implementation sendMessage_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAppMessage: (AppMessage *) appMessage
{
  self = [super init];
  __appMessage = [appMessage retain_stub];
  __appMessage_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"appMessage"])
  {
    __appMessage = [[decoder decodeObjectForKey: @"appMessage"] retain_stub];
    __appMessage_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__appMessage_isset)
  {
    [encoder encodeObject: __appMessage forKey: @"appMessage"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __appMessage_isset ? 2654435761 : 0;
  if (__appMessage_isset)
  {
    hash = (hash * 31) ^ [__appMessage hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[sendMessage_args class]]) {
    return NO;
  }
  sendMessage_args *other = (sendMessage_args *)anObject;
  if ((__appMessage_isset != other->__appMessage_isset) ||
      (__appMessage_isset && ((__appMessage || other->__appMessage) && ![__appMessage isEqual:other->__appMessage]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__appMessage release_stub];
  [super dealloc_stub];
}

- (AppMessage *) appMessage {
  return [[__appMessage retain_stub] autorelease_stub];
}

- (void) setAppMessage: (AppMessage *) appMessage {
  [appMessage retain_stub];
  [__appMessage release_stub];
  __appMessage = appMessage;
  __appMessage_isset = YES;
}

- (BOOL) appMessageIsSet {
  return __appMessage_isset;
}

- (void) unsetAppMessage {
  [__appMessage release_stub];
  __appMessage = nil;
  __appMessage_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          AppMessage *fieldValue = [[AppMessage alloc] init];
          [fieldValue read: inProtocol];
          [self setAppMessage: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"sendMessage_args"];
  if (__appMessage_isset) {
    if (__appMessage != nil) {
      [outProtocol writeFieldBeginWithName: @"appMessage" type: TType_STRUCT fieldID: 1];
      [__appMessage write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"sendMessage_args("];
  [ms appendString: @"appMessage:"];
  [ms appendFormat: @"%@", __appMessage];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface SendMessage_result : NSObject <TBase, NSCoding> {
  BOOL __success;
  AppException * __ouch;

  BOOL __success_isset;
  BOOL __ouch_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=success, setter=setSuccess:) BOOL success;
@property (nonatomic, retain, getter=ouch, setter=setOuch:) AppException * ouch;
#endif

- (id) init;
- (id) initWithSuccess: (BOOL) success ouch: (AppException *) ouch;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (BOOL) success;
- (void) setSuccess: (BOOL) success;
#endif
- (BOOL) successIsSet;

#if !__has_feature(objc_arc)
- (AppException *) ouch;
- (void) setOuch: (AppException *) ouch;
#endif
- (BOOL) ouchIsSet;

@end

@implementation SendMessage_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithSuccess: (BOOL) success ouch: (AppException *) ouch
{
  self = [super init];
  __success = success;
  __success_isset = YES;
  __ouch = [ouch retain_stub];
  __ouch_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"success"])
  {
    __success = [decoder decodeBoolForKey: @"success"];
    __success_isset = YES;
  }
  if ([decoder containsValueForKey: @"ouch"])
  {
    __ouch = [[decoder decodeObjectForKey: @"ouch"] retain_stub];
    __ouch_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__success_isset)
  {
    [encoder encodeBool: __success forKey: @"success"];
  }
  if (__ouch_isset)
  {
    [encoder encodeObject: __ouch forKey: @"ouch"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __success_isset ? 2654435761 : 0;
  if (__success_isset)
  {
    hash = (hash * 31) ^ [@(__success) hash];
  }
  hash = (hash * 31) ^ __ouch_isset ? 2654435761 : 0;
  if (__ouch_isset)
  {
    hash = (hash * 31) ^ [__ouch hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[SendMessage_result class]]) {
    return NO;
  }
  SendMessage_result *other = (SendMessage_result *)anObject;
  if ((__success_isset != other->__success_isset) ||
      (__success_isset && (__success != other->__success))) {
    return NO;
  }
  if ((__ouch_isset != other->__ouch_isset) ||
      (__ouch_isset && ((__ouch || other->__ouch) && ![__ouch isEqual:other->__ouch]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__ouch release_stub];
  [super dealloc_stub];
}

- (BOOL) success {
  return __success;
}

- (void) setSuccess: (BOOL) success {
  __success = success;
  __success_isset = YES;
}

- (BOOL) successIsSet {
  return __success_isset;
}

- (void) unsetSuccess {
  __success_isset = NO;
}

- (AppException *) ouch {
  return [[__ouch retain_stub] autorelease_stub];
}

- (void) setOuch: (AppException *) ouch {
  [ouch retain_stub];
  [__ouch release_stub];
  __ouch = ouch;
  __ouch_isset = YES;
}

- (BOOL) ouchIsSet {
  return __ouch_isset;
}

- (void) unsetOuch {
  [__ouch release_stub];
  __ouch = nil;
  __ouch_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 0:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setSuccess: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 1:
        if (fieldType == TType_STRUCT) {
          AppException *fieldValue = [[AppException alloc] init];
          [fieldValue read: inProtocol];
          [self setOuch: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"SendMessage_result"];

  if (__success_isset) {
    [outProtocol writeFieldBeginWithName: @"success" type: TType_BOOL fieldID: 0];
    [outProtocol writeBool: __success];
    [outProtocol writeFieldEnd];
  } else if (__ouch_isset) {
    if (__ouch != nil) {
      [outProtocol writeFieldBeginWithName: @"ouch" type: TType_STRUCT fieldID: 1];
      [__ouch write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"SendMessage_result("];
  [ms appendString: @"success:"];
  [ms appendFormat: @"%i", __success];
  [ms appendString: @",ouch:"];
  [ms appendFormat: @"%@", __ouch];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface authAppMessageResponse_args : NSObject <TBase, NSCoding> {
  AuthAppMessageResponse * __authAppMessageResponse;

  BOOL __authAppMessageResponse_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=authAppMessageResponse, setter=setAuthAppMessageResponse:) AuthAppMessageResponse * authAppMessageResponse;
#endif

- (id) init;
- (id) initWithAuthAppMessageResponse: (AuthAppMessageResponse *) authAppMessageResponse;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (AuthAppMessageResponse *) authAppMessageResponse;
- (void) setAuthAppMessageResponse: (AuthAppMessageResponse *) authAppMessageResponse;
#endif
- (BOOL) authAppMessageResponseIsSet;

@end

@implementation authAppMessageResponse_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithAuthAppMessageResponse: (AuthAppMessageResponse *) authAppMessageResponse
{
  self = [super init];
  __authAppMessageResponse = [authAppMessageResponse retain_stub];
  __authAppMessageResponse_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"authAppMessageResponse"])
  {
    __authAppMessageResponse = [[decoder decodeObjectForKey: @"authAppMessageResponse"] retain_stub];
    __authAppMessageResponse_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__authAppMessageResponse_isset)
  {
    [encoder encodeObject: __authAppMessageResponse forKey: @"authAppMessageResponse"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __authAppMessageResponse_isset ? 2654435761 : 0;
  if (__authAppMessageResponse_isset)
  {
    hash = (hash * 31) ^ [__authAppMessageResponse hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[authAppMessageResponse_args class]]) {
    return NO;
  }
  authAppMessageResponse_args *other = (authAppMessageResponse_args *)anObject;
  if ((__authAppMessageResponse_isset != other->__authAppMessageResponse_isset) ||
      (__authAppMessageResponse_isset && ((__authAppMessageResponse || other->__authAppMessageResponse) && ![__authAppMessageResponse isEqual:other->__authAppMessageResponse]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__authAppMessageResponse release_stub];
  [super dealloc_stub];
}

- (AuthAppMessageResponse *) authAppMessageResponse {
  return [[__authAppMessageResponse retain_stub] autorelease_stub];
}

- (void) setAuthAppMessageResponse: (AuthAppMessageResponse *) authAppMessageResponse {
  [authAppMessageResponse retain_stub];
  [__authAppMessageResponse release_stub];
  __authAppMessageResponse = authAppMessageResponse;
  __authAppMessageResponse_isset = YES;
}

- (BOOL) authAppMessageResponseIsSet {
  return __authAppMessageResponse_isset;
}

- (void) unsetAuthAppMessageResponse {
  [__authAppMessageResponse release_stub];
  __authAppMessageResponse = nil;
  __authAppMessageResponse_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          AuthAppMessageResponse *fieldValue = [[AuthAppMessageResponse alloc] init];
          [fieldValue read: inProtocol];
          [self setAuthAppMessageResponse: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"authAppMessageResponse_args"];
  if (__authAppMessageResponse_isset) {
    if (__authAppMessageResponse != nil) {
      [outProtocol writeFieldBeginWithName: @"authAppMessageResponse" type: TType_STRUCT fieldID: 1];
      [__authAppMessageResponse write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"authAppMessageResponse_args("];
  [ms appendString: @"authAppMessageResponse:"];
  [ms appendFormat: @"%@", __authAppMessageResponse];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface AuthAppMessageResponse_result : NSObject <TBase, NSCoding> {
  AppException * __ouch;

  BOOL __ouch_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=ouch, setter=setOuch:) AppException * ouch;
#endif

- (id) init;
- (id) initWithOuch: (AppException *) ouch;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (AppException *) ouch;
- (void) setOuch: (AppException *) ouch;
#endif
- (BOOL) ouchIsSet;

@end

@implementation AuthAppMessageResponse_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithOuch: (AppException *) ouch
{
  self = [super init];
  __ouch = [ouch retain_stub];
  __ouch_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"ouch"])
  {
    __ouch = [[decoder decodeObjectForKey: @"ouch"] retain_stub];
    __ouch_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__ouch_isset)
  {
    [encoder encodeObject: __ouch forKey: @"ouch"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __ouch_isset ? 2654435761 : 0;
  if (__ouch_isset)
  {
    hash = (hash * 31) ^ [__ouch hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[AuthAppMessageResponse_result class]]) {
    return NO;
  }
  AuthAppMessageResponse_result *other = (AuthAppMessageResponse_result *)anObject;
  if ((__ouch_isset != other->__ouch_isset) ||
      (__ouch_isset && ((__ouch || other->__ouch) && ![__ouch isEqual:other->__ouch]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__ouch release_stub];
  [super dealloc_stub];
}

- (AppException *) ouch {
  return [[__ouch retain_stub] autorelease_stub];
}

- (void) setOuch: (AppException *) ouch {
  [ouch retain_stub];
  [__ouch release_stub];
  __ouch = ouch;
  __ouch_isset = YES;
}

- (BOOL) ouchIsSet {
  return __ouch_isset;
}

- (void) unsetOuch {
  [__ouch release_stub];
  __ouch = nil;
  __ouch_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          AppException *fieldValue = [[AppException alloc] init];
          [fieldValue read: inProtocol];
          [self setOuch: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"AuthAppMessageResponse_result"];

  if (__ouch_isset) {
    if (__ouch != nil) {
      [outProtocol writeFieldBeginWithName: @"ouch" type: TType_STRUCT fieldID: 1];
      [__ouch write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"AuthAppMessageResponse_result("];
  [ms appendString: @"ouch:"];
  [ms appendFormat: @"%@", __ouch];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface proxyOpen_args : NSObject <TBase, NSCoding> {
  int64_t __handle;
  NSString * __ipHost;
  int32_t __port;
  BOOL __secure;
  BOOL __verifyCertificate;

  BOOL __handle_isset;
  BOOL __ipHost_isset;
  BOOL __port_isset;
  BOOL __secure_isset;
  BOOL __verifyCertificate_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=handle, setter=setHandle:) int64_t handle;
@property (nonatomic, retain, getter=ipHost, setter=setIpHost:) NSString * ipHost;
@property (nonatomic, getter=port, setter=setPort:) int32_t port;
@property (nonatomic, getter=secure, setter=setSecure:) BOOL secure;
@property (nonatomic, getter=verifyCertificate, setter=setVerifyCertificate:) BOOL verifyCertificate;
#endif

- (id) init;
- (id) initWithHandle: (int64_t) handle ipHost: (NSString *) ipHost port: (int32_t) port secure: (BOOL) secure verifyCertificate: (BOOL) verifyCertificate;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (int64_t) handle;
- (void) setHandle: (int64_t) handle;
#endif
- (BOOL) handleIsSet;

#if !__has_feature(objc_arc)
- (NSString *) ipHost;
- (void) setIpHost: (NSString *) ipHost;
#endif
- (BOOL) ipHostIsSet;

#if !__has_feature(objc_arc)
- (int32_t) port;
- (void) setPort: (int32_t) port;
#endif
- (BOOL) portIsSet;

#if !__has_feature(objc_arc)
- (BOOL) secure;
- (void) setSecure: (BOOL) secure;
#endif
- (BOOL) secureIsSet;

#if !__has_feature(objc_arc)
- (BOOL) verifyCertificate;
- (void) setVerifyCertificate: (BOOL) verifyCertificate;
#endif
- (BOOL) verifyCertificateIsSet;

@end

@implementation proxyOpen_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithHandle: (int64_t) handle ipHost: (NSString *) ipHost port: (int32_t) port secure: (BOOL) secure verifyCertificate: (BOOL) verifyCertificate
{
  self = [super init];
  __handle = handle;
  __handle_isset = YES;
  __ipHost = [ipHost retain_stub];
  __ipHost_isset = YES;
  __port = port;
  __port_isset = YES;
  __secure = secure;
  __secure_isset = YES;
  __verifyCertificate = verifyCertificate;
  __verifyCertificate_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"handle"])
  {
    __handle = [decoder decodeInt64ForKey: @"handle"];
    __handle_isset = YES;
  }
  if ([decoder containsValueForKey: @"ipHost"])
  {
    __ipHost = [[decoder decodeObjectForKey: @"ipHost"] retain_stub];
    __ipHost_isset = YES;
  }
  if ([decoder containsValueForKey: @"port"])
  {
    __port = [decoder decodeInt32ForKey: @"port"];
    __port_isset = YES;
  }
  if ([decoder containsValueForKey: @"secure"])
  {
    __secure = [decoder decodeBoolForKey: @"secure"];
    __secure_isset = YES;
  }
  if ([decoder containsValueForKey: @"verifyCertificate"])
  {
    __verifyCertificate = [decoder decodeBoolForKey: @"verifyCertificate"];
    __verifyCertificate_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__handle_isset)
  {
    [encoder encodeInt64: __handle forKey: @"handle"];
  }
  if (__ipHost_isset)
  {
    [encoder encodeObject: __ipHost forKey: @"ipHost"];
  }
  if (__port_isset)
  {
    [encoder encodeInt32: __port forKey: @"port"];
  }
  if (__secure_isset)
  {
    [encoder encodeBool: __secure forKey: @"secure"];
  }
  if (__verifyCertificate_isset)
  {
    [encoder encodeBool: __verifyCertificate forKey: @"verifyCertificate"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __handle_isset ? 2654435761 : 0;
  if (__handle_isset)
  {
    hash = (hash * 31) ^ [@(__handle) hash];
  }
  hash = (hash * 31) ^ __ipHost_isset ? 2654435761 : 0;
  if (__ipHost_isset)
  {
    hash = (hash * 31) ^ [__ipHost hash];
  }
  hash = (hash * 31) ^ __port_isset ? 2654435761 : 0;
  if (__port_isset)
  {
    hash = (hash * 31) ^ [@(__port) hash];
  }
  hash = (hash * 31) ^ __secure_isset ? 2654435761 : 0;
  if (__secure_isset)
  {
    hash = (hash * 31) ^ [@(__secure) hash];
  }
  hash = (hash * 31) ^ __verifyCertificate_isset ? 2654435761 : 0;
  if (__verifyCertificate_isset)
  {
    hash = (hash * 31) ^ [@(__verifyCertificate) hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[proxyOpen_args class]]) {
    return NO;
  }
  proxyOpen_args *other = (proxyOpen_args *)anObject;
  if ((__handle_isset != other->__handle_isset) ||
      (__handle_isset && (__handle != other->__handle))) {
    return NO;
  }
  if ((__ipHost_isset != other->__ipHost_isset) ||
      (__ipHost_isset && ((__ipHost || other->__ipHost) && ![__ipHost isEqual:other->__ipHost]))) {
    return NO;
  }
  if ((__port_isset != other->__port_isset) ||
      (__port_isset && (__port != other->__port))) {
    return NO;
  }
  if ((__secure_isset != other->__secure_isset) ||
      (__secure_isset && (__secure != other->__secure))) {
    return NO;
  }
  if ((__verifyCertificate_isset != other->__verifyCertificate_isset) ||
      (__verifyCertificate_isset && (__verifyCertificate != other->__verifyCertificate))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__ipHost release_stub];
  [super dealloc_stub];
}

- (int64_t) handle {
  return __handle;
}

- (void) setHandle: (int64_t) handle {
  __handle = handle;
  __handle_isset = YES;
}

- (BOOL) handleIsSet {
  return __handle_isset;
}

- (void) unsetHandle {
  __handle_isset = NO;
}

- (NSString *) ipHost {
  return [[__ipHost retain_stub] autorelease_stub];
}

- (void) setIpHost: (NSString *) ipHost {
  [ipHost retain_stub];
  [__ipHost release_stub];
  __ipHost = ipHost;
  __ipHost_isset = YES;
}

- (BOOL) ipHostIsSet {
  return __ipHost_isset;
}

- (void) unsetIpHost {
  [__ipHost release_stub];
  __ipHost = nil;
  __ipHost_isset = NO;
}

- (int32_t) port {
  return __port;
}

- (void) setPort: (int32_t) port {
  __port = port;
  __port_isset = YES;
}

- (BOOL) portIsSet {
  return __port_isset;
}

- (void) unsetPort {
  __port_isset = NO;
}

- (BOOL) secure {
  return __secure;
}

- (void) setSecure: (BOOL) secure {
  __secure = secure;
  __secure_isset = YES;
}

- (BOOL) secureIsSet {
  return __secure_isset;
}

- (void) unsetSecure {
  __secure_isset = NO;
}

- (BOOL) verifyCertificate {
  return __verifyCertificate;
}

- (void) setVerifyCertificate: (BOOL) verifyCertificate {
  __verifyCertificate = verifyCertificate;
  __verifyCertificate_isset = YES;
}

- (BOOL) verifyCertificateIsSet {
  return __verifyCertificate_isset;
}

- (void) unsetVerifyCertificate {
  __verifyCertificate_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setHandle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSString * fieldValue = [inProtocol readString];
          [self setIpHost: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 3:
        if (fieldType == TType_I32) {
          int32_t fieldValue = [inProtocol readI32];
          [self setPort: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 4:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setSecure: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 5:
        if (fieldType == TType_BOOL) {
          BOOL fieldValue = [inProtocol readBool];
          [self setVerifyCertificate: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"proxyOpen_args"];
  if (__handle_isset) {
    [outProtocol writeFieldBeginWithName: @"handle" type: TType_I64 fieldID: 1];
    [outProtocol writeI64: __handle];
    [outProtocol writeFieldEnd];
  }
  if (__ipHost_isset) {
    if (__ipHost != nil) {
      [outProtocol writeFieldBeginWithName: @"ipHost" type: TType_STRING fieldID: 2];
      [outProtocol writeString: __ipHost];
      [outProtocol writeFieldEnd];
    }
  }
  if (__port_isset) {
    [outProtocol writeFieldBeginWithName: @"port" type: TType_I32 fieldID: 3];
    [outProtocol writeI32: __port];
    [outProtocol writeFieldEnd];
  }
  if (__secure_isset) {
    [outProtocol writeFieldBeginWithName: @"secure" type: TType_BOOL fieldID: 4];
    [outProtocol writeBool: __secure];
    [outProtocol writeFieldEnd];
  }
  if (__verifyCertificate_isset) {
    [outProtocol writeFieldBeginWithName: @"verifyCertificate" type: TType_BOOL fieldID: 5];
    [outProtocol writeBool: __verifyCertificate];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"proxyOpen_args("];
  [ms appendString: @"handle:"];
  [ms appendFormat: @"%qi", __handle];
  [ms appendString: @",ipHost:"];
  [ms appendFormat: @"\"%@\"", __ipHost];
  [ms appendString: @",port:"];
  [ms appendFormat: @"%i", __port];
  [ms appendString: @",secure:"];
  [ms appendFormat: @"%i", __secure];
  [ms appendString: @",verifyCertificate:"];
  [ms appendFormat: @"%i", __verifyCertificate];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface ProxyOpen_result : NSObject <TBase, NSCoding> {
  AppException * __ouch;

  BOOL __ouch_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=ouch, setter=setOuch:) AppException * ouch;
#endif

- (id) init;
- (id) initWithOuch: (AppException *) ouch;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (AppException *) ouch;
- (void) setOuch: (AppException *) ouch;
#endif
- (BOOL) ouchIsSet;

@end

@implementation ProxyOpen_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithOuch: (AppException *) ouch
{
  self = [super init];
  __ouch = [ouch retain_stub];
  __ouch_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"ouch"])
  {
    __ouch = [[decoder decodeObjectForKey: @"ouch"] retain_stub];
    __ouch_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__ouch_isset)
  {
    [encoder encodeObject: __ouch forKey: @"ouch"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __ouch_isset ? 2654435761 : 0;
  if (__ouch_isset)
  {
    hash = (hash * 31) ^ [__ouch hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[ProxyOpen_result class]]) {
    return NO;
  }
  ProxyOpen_result *other = (ProxyOpen_result *)anObject;
  if ((__ouch_isset != other->__ouch_isset) ||
      (__ouch_isset && ((__ouch || other->__ouch) && ![__ouch isEqual:other->__ouch]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__ouch release_stub];
  [super dealloc_stub];
}

- (AppException *) ouch {
  return [[__ouch retain_stub] autorelease_stub];
}

- (void) setOuch: (AppException *) ouch {
  [ouch retain_stub];
  [__ouch release_stub];
  __ouch = ouch;
  __ouch_isset = YES;
}

- (BOOL) ouchIsSet {
  return __ouch_isset;
}

- (void) unsetOuch {
  [__ouch release_stub];
  __ouch = nil;
  __ouch_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          AppException *fieldValue = [[AppException alloc] init];
          [fieldValue read: inProtocol];
          [self setOuch: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ProxyOpen_result"];

  if (__ouch_isset) {
    if (__ouch != nil) {
      [outProtocol writeFieldBeginWithName: @"ouch" type: TType_STRUCT fieldID: 1];
      [__ouch write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ProxyOpen_result("];
  [ms appendString: @"ouch:"];
  [ms appendFormat: @"%@", __ouch];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface proxyData_args : NSObject <TBase, NSCoding> {
  int64_t __handle;
  NSData * __data;

  BOOL __handle_isset;
  BOOL __data_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=handle, setter=setHandle:) int64_t handle;
@property (nonatomic, retain, getter=data, setter=setData:) NSData * data;
#endif

- (id) init;
- (id) initWithHandle: (int64_t) handle data: (NSData *) data;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (int64_t) handle;
- (void) setHandle: (int64_t) handle;
#endif
- (BOOL) handleIsSet;

#if !__has_feature(objc_arc)
- (NSData *) data;
- (void) setData: (NSData *) data;
#endif
- (BOOL) dataIsSet;

@end

@implementation proxyData_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithHandle: (int64_t) handle data: (NSData *) data
{
  self = [super init];
  __handle = handle;
  __handle_isset = YES;
  __data = [data retain_stub];
  __data_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"handle"])
  {
    __handle = [decoder decodeInt64ForKey: @"handle"];
    __handle_isset = YES;
  }
  if ([decoder containsValueForKey: @"data"])
  {
    __data = [[decoder decodeObjectForKey: @"data"] retain_stub];
    __data_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__handle_isset)
  {
    [encoder encodeInt64: __handle forKey: @"handle"];
  }
  if (__data_isset)
  {
    [encoder encodeObject: __data forKey: @"data"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __handle_isset ? 2654435761 : 0;
  if (__handle_isset)
  {
    hash = (hash * 31) ^ [@(__handle) hash];
  }
  hash = (hash * 31) ^ __data_isset ? 2654435761 : 0;
  if (__data_isset)
  {
    hash = (hash * 31) ^ [__data hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[proxyData_args class]]) {
    return NO;
  }
  proxyData_args *other = (proxyData_args *)anObject;
  if ((__handle_isset != other->__handle_isset) ||
      (__handle_isset && (__handle != other->__handle))) {
    return NO;
  }
  if ((__data_isset != other->__data_isset) ||
      (__data_isset && ((__data || other->__data) && ![__data isEqual:other->__data]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__data release_stub];
  [super dealloc_stub];
}

- (int64_t) handle {
  return __handle;
}

- (void) setHandle: (int64_t) handle {
  __handle = handle;
  __handle_isset = YES;
}

- (BOOL) handleIsSet {
  return __handle_isset;
}

- (void) unsetHandle {
  __handle_isset = NO;
}

- (NSData *) data {
  return [[__data retain_stub] autorelease_stub];
}

- (void) setData: (NSData *) data {
  [data retain_stub];
  [__data release_stub];
  __data = data;
  __data_isset = YES;
}

- (BOOL) dataIsSet {
  return __data_isset;
}

- (void) unsetData {
  [__data release_stub];
  __data = nil;
  __data_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setHandle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      case 2:
        if (fieldType == TType_STRING) {
          NSData * fieldValue = [inProtocol readBinary];
          [self setData: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"proxyData_args"];
  if (__handle_isset) {
    [outProtocol writeFieldBeginWithName: @"handle" type: TType_I64 fieldID: 1];
    [outProtocol writeI64: __handle];
    [outProtocol writeFieldEnd];
  }
  if (__data_isset) {
    if (__data != nil) {
      [outProtocol writeFieldBeginWithName: @"data" type: TType_STRING fieldID: 2];
      [outProtocol writeBinary: __data];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"proxyData_args("];
  [ms appendString: @"handle:"];
  [ms appendFormat: @"%qi", __handle];
  [ms appendString: @",data:"];
  [ms appendFormat: @"\"%@\"", __data];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface ProxyData_result : NSObject <TBase, NSCoding> {
  AppException * __ouch;

  BOOL __ouch_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, retain, getter=ouch, setter=setOuch:) AppException * ouch;
#endif

- (id) init;
- (id) initWithOuch: (AppException *) ouch;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (AppException *) ouch;
- (void) setOuch: (AppException *) ouch;
#endif
- (BOOL) ouchIsSet;

@end

@implementation ProxyData_result

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithOuch: (AppException *) ouch
{
  self = [super init];
  __ouch = [ouch retain_stub];
  __ouch_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"ouch"])
  {
    __ouch = [[decoder decodeObjectForKey: @"ouch"] retain_stub];
    __ouch_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__ouch_isset)
  {
    [encoder encodeObject: __ouch forKey: @"ouch"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __ouch_isset ? 2654435761 : 0;
  if (__ouch_isset)
  {
    hash = (hash * 31) ^ [__ouch hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[ProxyData_result class]]) {
    return NO;
  }
  ProxyData_result *other = (ProxyData_result *)anObject;
  if ((__ouch_isset != other->__ouch_isset) ||
      (__ouch_isset && ((__ouch || other->__ouch) && ![__ouch isEqual:other->__ouch]))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [__ouch release_stub];
  [super dealloc_stub];
}

- (AppException *) ouch {
  return [[__ouch retain_stub] autorelease_stub];
}

- (void) setOuch: (AppException *) ouch {
  [ouch retain_stub];
  [__ouch release_stub];
  __ouch = ouch;
  __ouch_isset = YES;
}

- (BOOL) ouchIsSet {
  return __ouch_isset;
}

- (void) unsetOuch {
  [__ouch release_stub];
  __ouch = nil;
  __ouch_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_STRUCT) {
          AppException *fieldValue = [[AppException alloc] init];
          [fieldValue read: inProtocol];
          [self setOuch: fieldValue];
          [fieldValue release_stub];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ProxyData_result"];

  if (__ouch_isset) {
    if (__ouch != nil) {
      [outProtocol writeFieldBeginWithName: @"ouch" type: TType_STRUCT fieldID: 1];
      [__ouch write: outProtocol];
      [outProtocol writeFieldEnd];
    }
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ProxyData_result("];
  [ms appendString: @"ouch:"];
  [ms appendFormat: @"%@", __ouch];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface proxyClose_args : NSObject <TBase, NSCoding> {
  int64_t __handle;

  BOOL __handle_isset;
}

#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
@property (nonatomic, getter=handle, setter=setHandle:) int64_t handle;
#endif

- (id) init;
- (id) initWithHandle: (int64_t) handle;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

#if !__has_feature(objc_arc)
- (int64_t) handle;
- (void) setHandle: (int64_t) handle;
#endif
- (BOOL) handleIsSet;

@end

@implementation proxyClose_args

- (id) init
{
  self = [super init];
#if TARGET_OS_IPHONE || (MAC_OS_X_VERSION_MAX_ALLOWED >= MAC_OS_X_VERSION_10_5)
#endif
  return self;
}

- (id) initWithHandle: (int64_t) handle
{
  self = [super init];
  __handle = handle;
  __handle_isset = YES;
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  if ([decoder containsValueForKey: @"handle"])
  {
    __handle = [decoder decodeInt64ForKey: @"handle"];
    __handle_isset = YES;
  }
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
  if (__handle_isset)
  {
    [encoder encodeInt64: __handle forKey: @"handle"];
  }
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  hash = (hash * 31) ^ __handle_isset ? 2654435761 : 0;
  if (__handle_isset)
  {
    hash = (hash * 31) ^ [@(__handle) hash];
  }
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[proxyClose_args class]]) {
    return NO;
  }
  proxyClose_args *other = (proxyClose_args *)anObject;
  if ((__handle_isset != other->__handle_isset) ||
      (__handle_isset && (__handle != other->__handle))) {
    return NO;
  }
  return YES;
}

- (void) dealloc
{
  [super dealloc_stub];
}

- (int64_t) handle {
  return __handle;
}

- (void) setHandle: (int64_t) handle {
  __handle = handle;
  __handle_isset = YES;
}

- (BOOL) handleIsSet {
  return __handle_isset;
}

- (void) unsetHandle {
  __handle_isset = NO;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      case 1:
        if (fieldType == TType_I64) {
          int64_t fieldValue = [inProtocol readI64];
          [self setHandle: fieldValue];
        } else { 
          [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        }
        break;
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"proxyClose_args"];
  if (__handle_isset) {
    [outProtocol writeFieldBeginWithName: @"handle" type: TType_I64 fieldID: 1];
    [outProtocol writeI64: __handle];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"proxyClose_args("];
  [ms appendString: @"handle:"];
  [ms appendFormat: @"%qi", __handle];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@interface ProxyClose_result : NSObject <TBase, NSCoding> {
}

- (id) init;

- (void) read: (id <TProtocol>) inProtocol;
- (void) write: (id <TProtocol>) outProtocol;

- (void) validate;

@end

@implementation ProxyClose_result

- (id) init
{
  self = [super init];
  return self;
}

- (id) initWithCoder: (NSCoder *) decoder
{
  self = [super init];
  return self;
}

- (void) encodeWithCoder: (NSCoder *) encoder
{
}

- (NSUInteger) hash
{
  NSUInteger hash = 17;
  return hash;
}

- (BOOL) isEqual: (id) anObject
{
  if (self == anObject) {
    return YES;
  }
  if (![anObject isKindOfClass:[ProxyClose_result class]]) {
    return NO;
  }
  ProxyClose_result *other = (ProxyClose_result *)anObject;
  return YES;
}

- (void) read: (id <TProtocol>) inProtocol
{
  NSString * fieldName;
  int fieldType;
  int fieldID;

  [inProtocol readStructBeginReturningName: NULL];
  while (true)
  {
    [inProtocol readFieldBeginReturningName: &fieldName type: &fieldType fieldID: &fieldID];
    if (fieldType == TType_STOP) { 
      break;
    }
    switch (fieldID)
    {
      default:
        [TProtocolUtil skipType: fieldType onProtocol: inProtocol];
        break;
    }
    [inProtocol readFieldEnd];
  }
  [inProtocol readStructEnd];
}

- (void) write: (id <TProtocol>) outProtocol {
  [outProtocol writeStructBeginWithName: @"ProxyClose_result"];

  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
}

- (void) validate {
  // check for required fields
}

- (NSString *) description {
  NSMutableString * ms = [NSMutableString stringWithString: @"ProxyClose_result("];
  [ms appendString: @")"];
  return [NSString stringWithString: ms];
}

@end

@implementation ServerToAppClient
- (id) initWithProtocol: (id <TProtocol>) protocol
{
  return [self initWithInProtocol: protocol outProtocol: protocol];
}

- (id) initWithInProtocol: (id <TProtocol>) anInProtocol outProtocol: (id <TProtocol>) anOutProtocol
{
  self = [super init];
  inProtocol = [anInProtocol retain_stub];
  outProtocol = [anOutProtocol retain_stub];
  return self;
}

- (void) send_disconnect
{
  [outProtocol writeMessageBeginWithName: @"disconnect" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"disconnect_args"];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
}

- (void) recv_disconnect
{
  TApplicationException * x = [self checkIncomingMessageException];
  if (x != nil)  {
    @throw x;
  }
  Disconnect_result * result = [[[Disconnect_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result ouchIsSet]) {
    @throw [result ouch];
  }
  return;
}

- (void) disconnect
{
  [self send_disconnect];
  [[outProtocol transport] flush];
  [self recv_disconnect];
}

- (void) send_sendMessage: (AppMessage *) appMessage
{
  [outProtocol writeMessageBeginWithName: @"sendMessage" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"sendMessage_args"];
  if (appMessage != nil)  {
    [outProtocol writeFieldBeginWithName: @"appMessage" type: TType_STRUCT fieldID: 1];
    [appMessage write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
}

- (BOOL) recv_sendMessage
{
  TApplicationException * x = [self checkIncomingMessageException];
  if (x != nil)  {
    @throw x;
  }
  SendMessage_result * result = [[[SendMessage_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result successIsSet]) {
    return [result success];
  }
  if ([result ouchIsSet]) {
    @throw [result ouch];
  }
  @throw [TApplicationException exceptionWithType: TApplicationException_MISSING_RESULT
                                           reason: @"sendMessage failed: unknown result"];
}

- (BOOL) sendMessage: (AppMessage *) appMessage
{
  [self send_sendMessage : appMessage];
  [[outProtocol transport] flush];
  return [self recv_sendMessage];
}

- (void) send_authAppMessageResponse: (AuthAppMessageResponse *) authAppMessageResponse
{
  [outProtocol writeMessageBeginWithName: @"authAppMessageResponse" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"authAppMessageResponse_args"];
  if (authAppMessageResponse != nil)  {
    [outProtocol writeFieldBeginWithName: @"authAppMessageResponse" type: TType_STRUCT fieldID: 1];
    [authAppMessageResponse write: outProtocol];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
}

- (void) recv_authAppMessageResponse
{
  TApplicationException * x = [self checkIncomingMessageException];
  if (x != nil)  {
    @throw x;
  }
  AuthAppMessageResponse_result * result = [[[AuthAppMessageResponse_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result ouchIsSet]) {
    @throw [result ouch];
  }
  return;
}

- (void) authAppMessageResponse: (AuthAppMessageResponse *) authAppMessageResponse
{
  [self send_authAppMessageResponse : authAppMessageResponse];
  [[outProtocol transport] flush];
  [self recv_authAppMessageResponse];
}

- (void) send_proxyOpen: (int64_t) handle ipHost: (NSString *) ipHost port: (int32_t) port secure: (BOOL) secure verifyCertificate: (BOOL) verifyCertificate
{
  [outProtocol writeMessageBeginWithName: @"proxyOpen" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"proxyOpen_args"];
  [outProtocol writeFieldBeginWithName: @"handle" type: TType_I64 fieldID: 1];
  [outProtocol writeI64: handle];
  [outProtocol writeFieldEnd];
  if (ipHost != nil)  {
    [outProtocol writeFieldBeginWithName: @"ipHost" type: TType_STRING fieldID: 2];
    [outProtocol writeString: ipHost];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldBeginWithName: @"port" type: TType_I32 fieldID: 3];
  [outProtocol writeI32: port];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"secure" type: TType_BOOL fieldID: 4];
  [outProtocol writeBool: secure];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldBeginWithName: @"verifyCertificate" type: TType_BOOL fieldID: 5];
  [outProtocol writeBool: verifyCertificate];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
}

- (void) recv_proxyOpen
{
  TApplicationException * x = [self checkIncomingMessageException];
  if (x != nil)  {
    @throw x;
  }
  ProxyOpen_result * result = [[[ProxyOpen_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result ouchIsSet]) {
    @throw [result ouch];
  }
  return;
}

- (void) proxyOpen: (int64_t) handle ipHost: (NSString *) ipHost port: (int32_t) port secure: (BOOL) secure verifyCertificate: (BOOL) verifyCertificate
{
  [self send_proxyOpen : handle ipHost: ipHost port: port secure: secure verifyCertificate: verifyCertificate];
  [[outProtocol transport] flush];
  [self recv_proxyOpen];
}

- (void) send_proxyData: (int64_t) handle data: (NSData *) data
{
  [outProtocol writeMessageBeginWithName: @"proxyData" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"proxyData_args"];
  [outProtocol writeFieldBeginWithName: @"handle" type: TType_I64 fieldID: 1];
  [outProtocol writeI64: handle];
  [outProtocol writeFieldEnd];
  if (data != nil)  {
    [outProtocol writeFieldBeginWithName: @"data" type: TType_STRING fieldID: 2];
    [outProtocol writeBinary: data];
    [outProtocol writeFieldEnd];
  }
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
}

- (void) recv_proxyData
{
  TApplicationException * x = [self checkIncomingMessageException];
  if (x != nil)  {
    @throw x;
  }
  ProxyData_result * result = [[[ProxyData_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  if ([result ouchIsSet]) {
    @throw [result ouch];
  }
  return;
}

- (void) proxyData: (int64_t) handle data: (NSData *) data
{
  [self send_proxyData : handle data: data];
  [[outProtocol transport] flush];
  [self recv_proxyData];
}

- (void) send_proxyClose: (int64_t) handle
{
  [outProtocol writeMessageBeginWithName: @"proxyClose" type: TMessageType_CALL sequenceID: 0];
  [outProtocol writeStructBeginWithName: @"proxyClose_args"];
  [outProtocol writeFieldBeginWithName: @"handle" type: TType_I64 fieldID: 1];
  [outProtocol writeI64: handle];
  [outProtocol writeFieldEnd];
  [outProtocol writeFieldStop];
  [outProtocol writeStructEnd];
  [outProtocol writeMessageEnd];
}

- (void) recv_proxyClose
{
  TApplicationException * x = [self checkIncomingMessageException];
  if (x != nil)  {
    @throw x;
  }
  ProxyClose_result * result = [[[ProxyClose_result alloc] init] autorelease_stub];
  [result read: inProtocol];
  [inProtocol readMessageEnd];
  return;
}

- (void) proxyClose: (int64_t) handle
{
  [self send_proxyClose : handle];
  [[outProtocol transport] flush];
  [self recv_proxyClose];
}

@end

@implementation ServerToAppProcessor

- (id) initWithServerToApp: (id <ServerToApp>) service
{
self = [super init];
if (!self) {
  return nil;
}
mService = [service retain_stub];
mMethodMap = [[NSMutableDictionary dictionary] retain_stub];
{
  SEL s = @selector(process_disconnect_withSequenceID:inProtocol:outProtocol:);
  NSMethodSignature * sig = [self methodSignatureForSelector: s];
  NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
  [invocation setSelector: s];
  [invocation retainArguments];
  [mMethodMap setValue: invocation forKey: @"disconnect"];
}
{
  SEL s = @selector(process_sendMessage_withSequenceID:inProtocol:outProtocol:);
  NSMethodSignature * sig = [self methodSignatureForSelector: s];
  NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
  [invocation setSelector: s];
  [invocation retainArguments];
  [mMethodMap setValue: invocation forKey: @"sendMessage"];
}
{
  SEL s = @selector(process_authAppMessageResponse_withSequenceID:inProtocol:outProtocol:);
  NSMethodSignature * sig = [self methodSignatureForSelector: s];
  NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
  [invocation setSelector: s];
  [invocation retainArguments];
  [mMethodMap setValue: invocation forKey: @"authAppMessageResponse"];
}
{
  SEL s = @selector(process_proxyOpen_withSequenceID:inProtocol:outProtocol:);
  NSMethodSignature * sig = [self methodSignatureForSelector: s];
  NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
  [invocation setSelector: s];
  [invocation retainArguments];
  [mMethodMap setValue: invocation forKey: @"proxyOpen"];
}
{
  SEL s = @selector(process_proxyData_withSequenceID:inProtocol:outProtocol:);
  NSMethodSignature * sig = [self methodSignatureForSelector: s];
  NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
  [invocation setSelector: s];
  [invocation retainArguments];
  [mMethodMap setValue: invocation forKey: @"proxyData"];
}
{
  SEL s = @selector(process_proxyClose_withSequenceID:inProtocol:outProtocol:);
  NSMethodSignature * sig = [self methodSignatureForSelector: s];
  NSInvocation * invocation = [NSInvocation invocationWithMethodSignature: sig];
  [invocation setSelector: s];
  [invocation retainArguments];
  [mMethodMap setValue: invocation forKey: @"proxyClose"];
}
return self;
}

- (id<ServerToApp>) service
{
  return [[mService retain_stub] autorelease_stub];
}

- (BOOL) processOnInputProtocol: (id <TProtocol>) inProtocol
                 outputProtocol: (id <TProtocol>) outProtocol
{
  NSString * messageName;
  int messageType;
  int seqID;
  [inProtocol readMessageBeginReturningName: &messageName
                                       type: &messageType
                                 sequenceID: &seqID];
  NSInvocation * invocation = [mMethodMap valueForKey: messageName];
  if (invocation == nil) {
    [TProtocolUtil skipType: TType_STRUCT onProtocol: inProtocol];
    [inProtocol readMessageEnd];
    TApplicationException * x = [TApplicationException exceptionWithType: TApplicationException_UNKNOWN_METHOD reason: [NSString stringWithFormat: @"Invalid method name: '%@'", messageName]];
    [outProtocol writeMessageBeginWithName: messageName
                                      type: TMessageType_EXCEPTION
                                sequenceID: seqID];
    [x write: outProtocol];
    [outProtocol writeMessageEnd];
    [[outProtocol transport] flush];
    return YES;
  }
  // NSInvocation does not conform to NSCopying protocol
  NSInvocation * i = [NSInvocation invocationWithMethodSignature: [invocation methodSignature]];
  [i setSelector: [invocation selector]];
  [i setArgument: &seqID atIndex: 2];
  [i setArgument: &inProtocol atIndex: 3];
  [i setArgument: &outProtocol atIndex: 4];
  [i setTarget: self];
  [i invoke];
  return YES;
}

- (void) process_disconnect_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
disconnect_args * args = [[disconnect_args alloc] init];
[args read: inProtocol];
[inProtocol readMessageEnd];
Disconnect_result * result = [[Disconnect_result alloc] init];
[mService disconnect];
[outProtocol writeMessageBeginWithName: @"disconnect"
                                  type: TMessageType_REPLY
                            sequenceID: seqID];
[result write: outProtocol];
[outProtocol writeMessageEnd];
[[outProtocol transport] flush];
[result release_stub];
[args release_stub];
}

- (void) process_sendMessage_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
sendMessage_args * args = [[sendMessage_args alloc] init];
[args read: inProtocol];
[inProtocol readMessageEnd];
SendMessage_result * result = [[SendMessage_result alloc] init];
[result setSuccess: [mService sendMessage: [args appMessage]]];
[outProtocol writeMessageBeginWithName: @"sendMessage"
                                  type: TMessageType_REPLY
                            sequenceID: seqID];
[result write: outProtocol];
[outProtocol writeMessageEnd];
[[outProtocol transport] flush];
[result release_stub];
[args release_stub];
}

- (void) process_authAppMessageResponse_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
authAppMessageResponse_args * args = [[authAppMessageResponse_args alloc] init];
[args read: inProtocol];
[inProtocol readMessageEnd];
AuthAppMessageResponse_result * result = [[AuthAppMessageResponse_result alloc] init];
[mService authAppMessageResponse: [args authAppMessageResponse]];
[outProtocol writeMessageBeginWithName: @"authAppMessageResponse"
                                  type: TMessageType_REPLY
                            sequenceID: seqID];
[result write: outProtocol];
[outProtocol writeMessageEnd];
[[outProtocol transport] flush];
[result release_stub];
[args release_stub];
}

- (void) process_proxyOpen_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
proxyOpen_args * args = [[proxyOpen_args alloc] init];
[args read: inProtocol];
[inProtocol readMessageEnd];
ProxyOpen_result * result = [[ProxyOpen_result alloc] init];
[mService proxyOpen: [args handle] ipHost: [args ipHost] port: [args port] secure: [args secure] verifyCertificate: [args verifyCertificate]];
[outProtocol writeMessageBeginWithName: @"proxyOpen"
                                  type: TMessageType_REPLY
                            sequenceID: seqID];
[result write: outProtocol];
[outProtocol writeMessageEnd];
[[outProtocol transport] flush];
[result release_stub];
[args release_stub];
}

- (void) process_proxyData_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
proxyData_args * args = [[proxyData_args alloc] init];
[args read: inProtocol];
[inProtocol readMessageEnd];
ProxyData_result * result = [[ProxyData_result alloc] init];
[mService proxyData: [args handle] data: [args data]];
[outProtocol writeMessageBeginWithName: @"proxyData"
                                  type: TMessageType_REPLY
                            sequenceID: seqID];
[result write: outProtocol];
[outProtocol writeMessageEnd];
[[outProtocol transport] flush];
[result release_stub];
[args release_stub];
}

- (void) process_proxyClose_withSequenceID: (int32_t) seqID inProtocol: (id<TProtocol>) inProtocol outProtocol: (id<TProtocol>) outProtocol
{
proxyClose_args * args = [[proxyClose_args alloc] init];
[args read: inProtocol];
[inProtocol readMessageEnd];
ProxyClose_result * result = [[ProxyClose_result alloc] init];
[mService proxyClose: [args handle]];
[outProtocol writeMessageBeginWithName: @"proxyClose"
                                  type: TMessageType_REPLY
                            sequenceID: seqID];
[result write: outProtocol];
[outProtocol writeMessageEnd];
[[outProtocol transport] flush];
[result release_stub];
[args release_stub];
}

- (void) dealloc
{
[mService release_stub];
[mMethodMap release_stub];
[super dealloc_stub];
}

@end

