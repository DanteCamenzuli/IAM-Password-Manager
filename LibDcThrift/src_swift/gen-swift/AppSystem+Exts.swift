/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public func ==(lhs: AppException, rhs: AppException) -> Bool {
  return
    (lhs.error == rhs.error) &&
    (lhs.info == rhs.info)
}

extension AppException : CustomStringConvertible {

  public var description : String {
    var desc = "AppException("
    desc += "error=\(String(describing: self.error)), "
    desc += "info=\(String(describing: self.info))"
    return desc
  }

}

extension AppException : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (error.hashValue)
    result = prime &* result &+ (info?.hashValue ?? 0)
    return result
  }

}

extension AppException : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["error": 1, "info": 2, ]
  }

  public static var structName: String { return "AppException" }

  public static func read(from proto: TProtocol) throws -> AppException {
    _ = try proto.readStructBegin()
    var error: String!
    var info: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           error = try String.read(from: proto)
        case (2, .string):           info = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(error, named: "error")

    return AppException(error: error, info: info)
  }

}



public func ==(lhs: SdkConfig, rhs: SdkConfig) -> Bool {
  return
    (lhs.connectionKey == rhs.connectionKey) &&
    (lhs.serverUrl == rhs.serverUrl) &&
    (lhs.transportProtocol == rhs.transportProtocol) &&
    (lhs.serverPublicKey == rhs.serverPublicKey) &&
    (lhs.portalUrl == rhs.portalUrl)
}

extension SdkConfig : CustomStringConvertible {

  public var description : String {
    var desc = "SdkConfig("
    desc += "connectionKey=\(String(describing: self.connectionKey)), "
    desc += "serverUrl=\(String(describing: self.serverUrl)), "
    desc += "transportProtocol=\(String(describing: self.transportProtocol)), "
    desc += "serverPublicKey=\(String(describing: self.serverPublicKey)), "
    desc += "portalUrl=\(String(describing: self.portalUrl))"
    return desc
  }

}

extension SdkConfig : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (connectionKey.hashValue)
    result = prime &* result &+ (serverUrl.hashValue)
    result = prime &* result &+ (transportProtocol.hashValue)
    result = prime &* result &+ (serverPublicKey.hashValue)
    result = prime &* result &+ (portalUrl?.hashValue ?? 0)
    return result
  }

}

extension SdkConfig : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["connectionKey": 1, "serverUrl": 2, "transportProtocol": 3, "serverPublicKey": 4, "portalUrl": 5, ]
  }

  public static var structName: String { return "SdkConfig" }

  public static func read(from proto: TProtocol) throws -> SdkConfig {
    _ = try proto.readStructBegin()
    var connectionKey: Data!
    var serverUrl: String!
    var transportProtocol: String!
    var serverPublicKey: Data!
    var portalUrl: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           connectionKey = try Data.read(from: proto)
        case (2, .string):           serverUrl = try String.read(from: proto)
        case (3, .string):           transportProtocol = try String.read(from: proto)
        case (4, .string):           serverPublicKey = try Data.read(from: proto)
        case (5, .string):           portalUrl = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(connectionKey, named: "connectionKey")
    try proto.validateValue(serverUrl, named: "serverUrl")
    try proto.validateValue(transportProtocol, named: "transportProtocol")
    try proto.validateValue(serverPublicKey, named: "serverPublicKey")

    return SdkConfig(connectionKey: connectionKey, serverUrl: serverUrl, transportProtocol: transportProtocol, serverPublicKey: serverPublicKey, portalUrl: portalUrl)
  }

}



public func ==(lhs: AuthGatewayConfig, rhs: AuthGatewayConfig) -> Bool {
  return
    (lhs.name == rhs.name) &&
    (lhs.sharedSecret == rhs.sharedSecret) &&
    (lhs.tenantName == rhs.tenantName)
}

extension AuthGatewayConfig : CustomStringConvertible {

  public var description : String {
    var desc = "AuthGatewayConfig("
    desc += "name=\(String(describing: self.name)), "
    desc += "sharedSecret=\(String(describing: self.sharedSecret)), "
    desc += "tenantName=\(String(describing: self.tenantName))"
    return desc
  }

}

extension AuthGatewayConfig : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (name.hashValue)
    result = prime &* result &+ (sharedSecret.hashValue)
    result = prime &* result &+ (tenantName.hashValue)
    return result
  }

}

extension AuthGatewayConfig : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["name": 1, "sharedSecret": 2, "tenantName": 3, ]
  }

  public static var structName: String { return "AuthGatewayConfig" }

  public static func read(from proto: TProtocol) throws -> AuthGatewayConfig {
    _ = try proto.readStructBegin()
    var name: String!
    var sharedSecret: Data!
    var tenantName: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           name = try String.read(from: proto)
        case (2, .string):           sharedSecret = try Data.read(from: proto)
        case (3, .string):           tenantName = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(name, named: "name")
    try proto.validateValue(sharedSecret, named: "sharedSecret")
    try proto.validateValue(tenantName, named: "tenantName")

    return AuthGatewayConfig(name: name, sharedSecret: sharedSecret, tenantName: tenantName)
  }

}



public func ==(lhs: SdkSettings, rhs: SdkSettings) -> Bool {
  return
    (lhs.deviceId == rhs.deviceId) &&
    (lhs.userId == rhs.userId) &&
    (lhs.deviceName == rhs.deviceName) &&
    (lhs.privateKey == rhs.privateKey) &&
    (lhs.publicKey == rhs.publicKey) &&
    (lhs.offlineKey == rhs.offlineKey) &&
    (lhs.passcodeValidFor == rhs.passcodeValidFor) &&
    (lhs.safe == rhs.safe) &&
    (lhs.sessionCookie == rhs.sessionCookie) &&
    (lhs.sessionCookieExpiresOn == rhs.sessionCookieExpiresOn)
}

extension SdkSettings : CustomStringConvertible {

  public var description : String {
    var desc = "SdkSettings("
    desc += "deviceId=\(String(describing: self.deviceId)), "
    desc += "userId=\(String(describing: self.userId)), "
    desc += "deviceName=\(String(describing: self.deviceName)), "
    desc += "privateKey=\(String(describing: self.privateKey)), "
    desc += "publicKey=\(String(describing: self.publicKey)), "
    desc += "offlineKey=\(String(describing: self.offlineKey)), "
    desc += "passcodeValidFor=\(String(describing: self.passcodeValidFor)), "
    desc += "safe=\(String(describing: self.safe)), "
    desc += "sessionCookie=\(String(describing: self.sessionCookie)), "
    desc += "sessionCookieExpiresOn=\(String(describing: self.sessionCookieExpiresOn))"
    return desc
  }

}

extension SdkSettings : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (deviceId.hashValue)
    result = prime &* result &+ (userId.hashValue)
    result = prime &* result &+ (deviceName.hashValue)
    result = prime &* result &+ (privateKey.hashValue)
    result = prime &* result &+ (publicKey.hashValue)
    result = prime &* result &+ (offlineKey.hashValue)
    result = prime &* result &+ (passcodeValidFor.hashValue)
    result = prime &* result &+ (safe.hashValue)
    result = prime &* result &+ (sessionCookie.hashValue)
    result = prime &* result &+ (sessionCookieExpiresOn.hashValue)
    return result
  }

}

extension SdkSettings : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["deviceId": 1, "userId": 2, "deviceName": 3, "privateKey": 4, "publicKey": 5, "offlineKey": 6, "passcodeValidFor": 7, "safe": 8, "sessionCookie": 9, "sessionCookieExpiresOn": 10, ]
  }

  public static var structName: String { return "SdkSettings" }

  public static func read(from proto: TProtocol) throws -> SdkSettings {
    _ = try proto.readStructBegin()
    var deviceId: Int32!
    var userId: String!
    var deviceName: String!
    var privateKey: Data!
    var publicKey: Data!
    var offlineKey: Data!
    var passcodeValidFor: Int32!
    var safe: TMap<String, String>!
    var sessionCookie: Data!
    var sessionCookieExpiresOn: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             deviceId = try Int32.read(from: proto)
        case (2, .string):           userId = try String.read(from: proto)
        case (3, .string):           deviceName = try String.read(from: proto)
        case (4, .string):           privateKey = try Data.read(from: proto)
        case (5, .string):           publicKey = try Data.read(from: proto)
        case (6, .string):           offlineKey = try Data.read(from: proto)
        case (7, .i32):             passcodeValidFor = try Int32.read(from: proto)
        case (8, .map):             safe = try TMap<String, String>.read(from: proto)
        case (9, .string):           sessionCookie = try Data.read(from: proto)
        case (10, .i32):             sessionCookieExpiresOn = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(deviceId, named: "deviceId")
    try proto.validateValue(userId, named: "userId")
    try proto.validateValue(deviceName, named: "deviceName")
    try proto.validateValue(privateKey, named: "privateKey")
    try proto.validateValue(publicKey, named: "publicKey")
    try proto.validateValue(offlineKey, named: "offlineKey")
    try proto.validateValue(passcodeValidFor, named: "passcodeValidFor")
    try proto.validateValue(safe, named: "safe")
    try proto.validateValue(sessionCookie, named: "sessionCookie")
    try proto.validateValue(sessionCookieExpiresOn, named: "sessionCookieExpiresOn")

    return SdkSettings(deviceId: deviceId, userId: userId, deviceName: deviceName, privateKey: privateKey, publicKey: publicKey, offlineKey: offlineKey, passcodeValidFor: passcodeValidFor, safe: safe, sessionCookie: sessionCookie, sessionCookieExpiresOn: sessionCookieExpiresOn)
  }

}



public func ==(lhs: MsgAttachment, rhs: MsgAttachment) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.name == rhs.name) &&
    (lhs.mimeType == rhs.mimeType) &&
    (lhs.size == rhs.size)
}

extension MsgAttachment : CustomStringConvertible {

  public var description : String {
    var desc = "MsgAttachment("
    desc += "id=\(String(describing: self.id)), "
    desc += "name=\(String(describing: self.name)), "
    desc += "mimeType=\(String(describing: self.mimeType)), "
    desc += "size=\(String(describing: self.size))"
    return desc
  }

}

extension MsgAttachment : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (id.hashValue)
    result = prime &* result &+ (name.hashValue)
    result = prime &* result &+ (mimeType.hashValue)
    result = prime &* result &+ (size.hashValue)
    return result
  }

}

extension MsgAttachment : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "name": 2, "mimeType": 3, "size": 4, ]
  }

  public static var structName: String { return "MsgAttachment" }

  public static func read(from proto: TProtocol) throws -> MsgAttachment {
    _ = try proto.readStructBegin()
    var id: Int64!
    var name: String!
    var mimeType: String!
    var size: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i64):             id = try Int64.read(from: proto)
        case (2, .string):           name = try String.read(from: proto)
        case (3, .string):           mimeType = try String.read(from: proto)
        case (4, .i32):             size = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(name, named: "name")
    try proto.validateValue(mimeType, named: "mimeType")
    try proto.validateValue(size, named: "size")

    return MsgAttachment(id: id, name: name, mimeType: mimeType, size: size)
  }

}



public func ==(lhs: AppMessage, rhs: AppMessage) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.priority == rhs.priority) &&
    (lhs.templateId == rhs.templateId) &&
    (lhs.signitureRequired == rhs.signitureRequired) &&
    (lhs.responseRequired == rhs.responseRequired) &&
    (lhs.responseTime == rhs.responseTime) &&
    (lhs.responseTo == rhs.responseTo) &&
    (lhs.data == rhs.data)
}

extension AppMessage : CustomStringConvertible {

  public var description : String {
    var desc = "AppMessage("
    desc += "id=\(String(describing: self.id)), "
    desc += "priority=\(String(describing: self.priority)), "
    desc += "templateId=\(String(describing: self.templateId)), "
    desc += "signitureRequired=\(String(describing: self.signitureRequired)), "
    desc += "responseRequired=\(String(describing: self.responseRequired)), "
    desc += "responseTime=\(String(describing: self.responseTime)), "
    desc += "responseTo=\(String(describing: self.responseTo)), "
    desc += "data=\(String(describing: self.data))"
    return desc
  }

}

extension AppMessage : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (id.hashValue)
    result = prime &* result &+ (priority.hashValue)
    result = prime &* result &+ (templateId.hashValue)
    result = prime &* result &+ (signitureRequired.hashValue)
    result = prime &* result &+ (responseRequired.hashValue)
    result = prime &* result &+ (responseTime.hashValue)
    result = prime &* result &+ (responseTo.hashValue)
    result = prime &* result &+ (data.hashValue)
    return result
  }

}

extension AppMessage : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "priority": 2, "templateId": 3, "signitureRequired": 4, "responseRequired": 5, "responseTime": 6, "responseTo": 7, "data": 8, ]
  }

  public static var structName: String { return "AppMessage" }

  public static func read(from proto: TProtocol) throws -> AppMessage {
    _ = try proto.readStructBegin()
    var id: Int64!
    var priority: MsgPriority!
    var templateId: Int32!
    var signitureRequired: Bool!
    var responseRequired: Bool!
    var responseTime: Int32!
    var responseTo: Int64!
    var data: TMap<String, String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i64):             id = try Int64.read(from: proto)
        case (2, .i32):             priority = try MsgPriority.read(from: proto)
        case (3, .i32):             templateId = try Int32.read(from: proto)
        case (4, .bool):            signitureRequired = try Bool.read(from: proto)
        case (5, .bool):            responseRequired = try Bool.read(from: proto)
        case (6, .i32):             responseTime = try Int32.read(from: proto)
        case (7, .i64):             responseTo = try Int64.read(from: proto)
        case (8, .map):             data = try TMap<String, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(priority, named: "priority")
    try proto.validateValue(templateId, named: "templateId")
    try proto.validateValue(signitureRequired, named: "signitureRequired")
    try proto.validateValue(responseRequired, named: "responseRequired")
    try proto.validateValue(responseTime, named: "responseTime")
    try proto.validateValue(responseTo, named: "responseTo")
    try proto.validateValue(data, named: "data")

    return AppMessage(id: id, priority: priority, templateId: templateId, signitureRequired: signitureRequired, responseRequired: responseRequired, responseTime: responseTime, responseTo: responseTo, data: data)
  }

}



public func ==(lhs: AppMessageResponse, rhs: AppMessageResponse) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.actionId == rhs.actionId) &&
    (lhs.errorCode == rhs.errorCode) &&
    (lhs.errorMessage == rhs.errorMessage) &&
    (lhs.read == rhs.read) &&
    (lhs.responseData == rhs.responseData) &&
    (lhs.signature == rhs.signature)
}

extension AppMessageResponse : CustomStringConvertible {

  public var description : String {
    var desc = "AppMessageResponse("
    desc += "id=\(String(describing: self.id)), "
    desc += "actionId=\(String(describing: self.actionId)), "
    desc += "errorCode=\(String(describing: self.errorCode)), "
    desc += "errorMessage=\(String(describing: self.errorMessage)), "
    desc += "read=\(String(describing: self.read)), "
    desc += "responseData=\(String(describing: self.responseData)), "
    desc += "signature=\(String(describing: self.signature))"
    return desc
  }

}

extension AppMessageResponse : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (id.hashValue)
    result = prime &* result &+ (actionId.hashValue)
    result = prime &* result &+ (errorCode.hashValue)
    result = prime &* result &+ (errorMessage.hashValue)
    result = prime &* result &+ (read.hashValue)
    result = prime &* result &+ (responseData.hashValue)
    result = prime &* result &+ (signature?.hashValue ?? 0)
    return result
  }

}

extension AppMessageResponse : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "actionId": 2, "errorCode": 3, "errorMessage": 4, "read": 5, "responseData": 6, "signature": 7, ]
  }

  public static var structName: String { return "AppMessageResponse" }

  public static func read(from proto: TProtocol) throws -> AppMessageResponse {
    _ = try proto.readStructBegin()
    var id: Int64!
    var actionId: String!
    var errorCode: AppErrorCodes!
    var errorMessage: String!
    var read: Bool!
    var responseData: TMap<String, String>!
    var signature: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i64):             id = try Int64.read(from: proto)
        case (2, .string):           actionId = try String.read(from: proto)
        case (3, .i32):             errorCode = try AppErrorCodes.read(from: proto)
        case (4, .string):           errorMessage = try String.read(from: proto)
        case (5, .bool):            read = try Bool.read(from: proto)
        case (6, .map):             responseData = try TMap<String, String>.read(from: proto)
        case (7, .string):           signature = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(actionId, named: "actionId")
    try proto.validateValue(errorCode, named: "errorCode")
    try proto.validateValue(errorMessage, named: "errorMessage")
    try proto.validateValue(read, named: "read")
    try proto.validateValue(responseData, named: "responseData")

    return AppMessageResponse(id: id, actionId: actionId, errorCode: errorCode, errorMessage: errorMessage, read: read, responseData: responseData, signature: signature)
  }

}



public func ==(lhs: AuthAppMessageResponse, rhs: AuthAppMessageResponse) -> Bool {
  return
    (lhs.succesful == rhs.succesful) &&
    (lhs.errorCode == rhs.errorCode) &&
    (lhs.errorMessage == rhs.errorMessage) &&
    (lhs.userKey == rhs.userKey) &&
    (lhs.sessionCookieExpiresOn == rhs.sessionCookieExpiresOn) &&
    (lhs.sessionCookie == rhs.sessionCookie) &&
    (lhs.msgId == rhs.msgId)
}

extension AuthAppMessageResponse : CustomStringConvertible {

  public var description : String {
    var desc = "AuthAppMessageResponse("
    desc += "succesful=\(String(describing: self.succesful)), "
    desc += "errorCode=\(String(describing: self.errorCode)), "
    desc += "errorMessage=\(String(describing: self.errorMessage)), "
    desc += "userKey=\(String(describing: self.userKey)), "
    desc += "sessionCookieExpiresOn=\(String(describing: self.sessionCookieExpiresOn)), "
    desc += "sessionCookie=\(String(describing: self.sessionCookie)), "
    desc += "msgId=\(String(describing: self.msgId))"
    return desc
  }

}

extension AuthAppMessageResponse : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (succesful.hashValue)
    result = prime &* result &+ (errorCode?.hashValue ?? 0)
    result = prime &* result &+ (errorMessage?.hashValue ?? 0)
    result = prime &* result &+ (userKey?.hashValue ?? 0)
    result = prime &* result &+ (sessionCookieExpiresOn?.hashValue ?? 0)
    result = prime &* result &+ (sessionCookie?.hashValue ?? 0)
    result = prime &* result &+ (msgId.hashValue)
    return result
  }

}

extension AuthAppMessageResponse : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["succesful": 1, "errorCode": 2, "errorMessage": 3, "userKey": 4, "sessionCookieExpiresOn": 5, "sessionCookie": 6, "msgId": 7, ]
  }

  public static var structName: String { return "AuthAppMessageResponse" }

  public static func read(from proto: TProtocol) throws -> AuthAppMessageResponse {
    _ = try proto.readStructBegin()
    var succesful: Bool!
    var errorCode: String?
    var errorMessage: String?
    var userKey: Data?
    var sessionCookieExpiresOn: Int32?
    var sessionCookie: String?
    var msgId: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .bool):            succesful = try Bool.read(from: proto)
        case (2, .string):           errorCode = try String.read(from: proto)
        case (3, .string):           errorMessage = try String.read(from: proto)
        case (4, .string):           userKey = try Data.read(from: proto)
        case (5, .i32):             sessionCookieExpiresOn = try Int32.read(from: proto)
        case (6, .string):           sessionCookie = try String.read(from: proto)
        case (7, .i64):             msgId = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(succesful, named: "succesful")
    try proto.validateValue(msgId, named: "msgId")

    return AuthAppMessageResponse(succesful: succesful, errorCode: errorCode, errorMessage: errorMessage, userKey: userKey, sessionCookieExpiresOn: sessionCookieExpiresOn, sessionCookie: sessionCookie, msgId: msgId)
  }

}



public func ==(lhs: AppVersion, rhs: AppVersion) -> Bool {
  return
    (lhs.version == rhs.version) &&
    (lhs.name == rhs.name) &&
    (lhs.state == rhs.state)
}

extension AppVersion : CustomStringConvertible {

  public var description : String {
    var desc = "AppVersion("
    desc += "version=\(String(describing: self.version)), "
    desc += "name=\(String(describing: self.name)), "
    desc += "state=\(String(describing: self.state))"
    return desc
  }

}

extension AppVersion : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (version.hashValue)
    result = prime &* result &+ (name.hashValue)
    result = prime &* result &+ (state.hashValue)
    return result
  }

}

extension AppVersion : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["version": 1, "name": 2, "state": 3, ]
  }

  public static var structName: String { return "AppVersion" }

  public static func read(from proto: TProtocol) throws -> AppVersion {
    _ = try proto.readStructBegin()
    var version: Int32!
    var name: String!
    var state: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             version = try Int32.read(from: proto)
        case (2, .string):           name = try String.read(from: proto)
        case (3, .string):           state = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(version, named: "version")
    try proto.validateValue(name, named: "name")
    try proto.validateValue(state, named: "state")

    return AppVersion(version: version, name: name, state: state)
  }

}



public func ==(lhs: Template, rhs: Template) -> Bool {
  return
    (lhs.id == rhs.id) &&
    (lhs.name == rhs.name) &&
    (lhs.locale == rhs.locale) &&
    (lhs.content == rhs.content)
}

extension Template : CustomStringConvertible {

  public var description : String {
    var desc = "Template("
    desc += "id=\(String(describing: self.id)), "
    desc += "name=\(String(describing: self.name)), "
    desc += "locale=\(String(describing: self.locale)), "
    desc += "content=\(String(describing: self.content))"
    return desc
  }

}

extension Template : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (id.hashValue)
    result = prime &* result &+ (name.hashValue)
    result = prime &* result &+ (locale.hashValue)
    result = prime &* result &+ (content?.hashValue ?? 0)
    return result
  }

}

extension Template : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["id": 1, "name": 2, "locale": 3, "content": 4, ]
  }

  public static var structName: String { return "Template" }

  public static func read(from proto: TProtocol) throws -> Template {
    _ = try proto.readStructBegin()
    var id: Int32!
    var name: String!
    var locale: String!
    var content: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             id = try Int32.read(from: proto)
        case (2, .string):           name = try String.read(from: proto)
        case (3, .string):           locale = try String.read(from: proto)
        case (4, .string):           content = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")
    try proto.validateValue(name, named: "name")
    try proto.validateValue(locale, named: "locale")

    return Template(id: id, name: name, locale: locale, content: content)
  }

}



public func ==(lhs: SdkCloudSafeKey, rhs: SdkCloudSafeKey) -> Bool {
  return
    (lhs.owner == rhs.owner) &&
    (lhs.name == rhs.name)
}

extension SdkCloudSafeKey : CustomStringConvertible {

  public var description : String {
    var desc = "SdkCloudSafeKey("
    desc += "owner=\(String(describing: self.owner)), "
    desc += "name=\(String(describing: self.name))"
    return desc
  }

}

extension SdkCloudSafeKey : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (owner.hashValue)
    result = prime &* result &+ (name.hashValue)
    return result
  }

}

extension SdkCloudSafeKey : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["owner": 1, "name": 2, ]
  }

  public static var structName: String { return "SdkCloudSafeKey" }

  public static func read(from proto: TProtocol) throws -> SdkCloudSafeKey {
    _ = try proto.readStructBegin()
    var owner: CloudSafeOwner!
    var name: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             owner = try CloudSafeOwner.read(from: proto)
        case (2, .string):           name = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(owner, named: "owner")
    try proto.validateValue(name, named: "name")

    return SdkCloudSafeKey(owner: owner, name: name)
  }

}



public func ==(lhs: SdkCloudSafe, rhs: SdkCloudSafe) -> Bool {
  return
    (lhs.uniqueKey == rhs.uniqueKey) &&
    (lhs.content == rhs.content) &&
    (lhs.options == rhs.options) &&
    (lhs.discardAfter == rhs.discardAfter) &&
    (lhs.lastModified == rhs.lastModified) &&
    (lhs.signature == rhs.signature) &&
    (lhs.length == rhs.length) &&
    (lhs.sharedUser == rhs.sharedUser) &&
    (lhs.writeAccess == rhs.writeAccess)
}

extension SdkCloudSafe : CustomStringConvertible {

  public var description : String {
    var desc = "SdkCloudSafe("
    desc += "uniqueKey=\(String(describing: self.uniqueKey)), "
    desc += "content=\(String(describing: self.content)), "
    desc += "options=\(String(describing: self.options)), "
    desc += "discardAfter=\(String(describing: self.discardAfter)), "
    desc += "lastModified=\(String(describing: self.lastModified)), "
    desc += "signature=\(String(describing: self.signature)), "
    desc += "length=\(String(describing: self.length)), "
    desc += "sharedUser=\(String(describing: self.sharedUser)), "
    desc += "writeAccess=\(String(describing: self.writeAccess))"
    return desc
  }

}

extension SdkCloudSafe : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (uniqueKey.hashValue)
    result = prime &* result &+ (content.hashValue)
    result = prime &* result &+ (options.hashValue)
    result = prime &* result &+ (discardAfter.hashValue)
    result = prime &* result &+ (lastModified.hashValue)
    result = prime &* result &+ (signature.hashValue)
    result = prime &* result &+ (length.hashValue)
    result = prime &* result &+ (sharedUser.hashValue)
    result = prime &* result &+ (writeAccess.hashValue)
    return result
  }

}

extension SdkCloudSafe : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["uniqueKey": 1, "content": 2, "options": 3, "discardAfter": 4, "lastModified": 5, "signature": 6, "length": 7, "sharedUser": 8, "writeAccess": 9, ]
  }

  public static var structName: String { return "SdkCloudSafe" }

  public static func read(from proto: TProtocol) throws -> SdkCloudSafe {
    _ = try proto.readStructBegin()
    var uniqueKey: SdkCloudSafeKey!
    var content: Data!
    var options: String!
    var discardAfter: Int64!
    var lastModified: Int64!
    var signature: Data!
    var length: Int64!
    var sharedUser: String!
    var writeAccess: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           uniqueKey = try SdkCloudSafeKey.read(from: proto)
        case (2, .string):           content = try Data.read(from: proto)
        case (3, .string):           options = try String.read(from: proto)
        case (4, .i64):             discardAfter = try Int64.read(from: proto)
        case (5, .i64):             lastModified = try Int64.read(from: proto)
        case (6, .string):           signature = try Data.read(from: proto)
        case (7, .i64):             length = try Int64.read(from: proto)
        case (8, .string):           sharedUser = try String.read(from: proto)
        case (9, .bool):            writeAccess = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(uniqueKey, named: "uniqueKey")
    try proto.validateValue(content, named: "content")
    try proto.validateValue(options, named: "options")
    try proto.validateValue(discardAfter, named: "discardAfter")
    try proto.validateValue(lastModified, named: "lastModified")
    try proto.validateValue(signature, named: "signature")
    try proto.validateValue(length, named: "length")
    try proto.validateValue(sharedUser, named: "sharedUser")
    try proto.validateValue(writeAccess, named: "writeAccess")

    return SdkCloudSafe(uniqueKey: uniqueKey, content: content, options: options, discardAfter: discardAfter, lastModified: lastModified, signature: signature, length: length, sharedUser: sharedUser, writeAccess: writeAccess)
  }

}



public func ==(lhs: User, rhs: User) -> Bool {
  return
    (lhs.loginId == rhs.loginId) &&
    (lhs.updatePushNotification == rhs.updatePushNotification) &&
    (lhs.usingReverseProxy == rhs.usingReverseProxy)
}

extension User : CustomStringConvertible {

  public var description : String {
    var desc = "User("
    desc += "loginId=\(String(describing: self.loginId)), "
    desc += "updatePushNotification=\(String(describing: self.updatePushNotification)), "
    desc += "usingReverseProxy=\(String(describing: self.usingReverseProxy))"
    return desc
  }

}

extension User : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (loginId.hashValue)
    result = prime &* result &+ (updatePushNotification.hashValue)
    result = prime &* result &+ (usingReverseProxy.hashValue)
    return result
  }

}

extension User : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["loginId": 1, "updatePushNotification": 2, "usingReverseProxy": 3, ]
  }

  public static var structName: String { return "User" }

  public static func read(from proto: TProtocol) throws -> User {
    _ = try proto.readStructBegin()
    var loginId: String!
    var updatePushNotification: Bool!
    var usingReverseProxy: Bool!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           loginId = try String.read(from: proto)
        case (2, .bool):            updatePushNotification = try Bool.read(from: proto)
        case (3, .bool):            usingReverseProxy = try Bool.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(loginId, named: "loginId")
    try proto.validateValue(updatePushNotification, named: "updatePushNotification")
    try proto.validateValue(usingReverseProxy, named: "usingReverseProxy")

    return User(loginId: loginId, updatePushNotification: updatePushNotification, usingReverseProxy: usingReverseProxy)
  }

}



public func ==(lhs: ActivatedUsers, rhs: ActivatedUsers) -> Bool {
  return
    (lhs.users == rhs.users)
}

extension ActivatedUsers : CustomStringConvertible {

  public var description : String {
    var desc = "ActivatedUsers("
    desc += "users=\(String(describing: self.users))"
    return desc
  }

}

extension ActivatedUsers : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (users.hashValue)
    return result
  }

}

extension ActivatedUsers : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["users": 1, ]
  }

  public static var structName: String { return "ActivatedUsers" }

  public static func read(from proto: TProtocol) throws -> ActivatedUsers {
    _ = try proto.readStructBegin()
    var users: TList<User>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            users = try TList<User>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(users, named: "users")

    return ActivatedUsers(users: users)
  }

}



public func ==(lhs: RpOpen, rhs: RpOpen) -> Bool {
  return
    (lhs.remoteAddress == rhs.remoteAddress) &&
    (lhs.appVersion == rhs.appVersion) &&
    (lhs.libVersion == rhs.libVersion) &&
    (lhs.tenantName == rhs.tenantName)
}

extension RpOpen : CustomStringConvertible {

  public var description : String {
    var desc = "RpOpen("
    desc += "remoteAddress=\(String(describing: self.remoteAddress)), "
    desc += "appVersion=\(String(describing: self.appVersion)), "
    desc += "libVersion=\(String(describing: self.libVersion)), "
    desc += "tenantName=\(String(describing: self.tenantName))"
    return desc
  }

}

extension RpOpen : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (remoteAddress.hashValue)
    result = prime &* result &+ (appVersion.hashValue)
    result = prime &* result &+ (libVersion.hashValue)
    result = prime &* result &+ (tenantName.hashValue)
    return result
  }

}

extension RpOpen : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["remoteAddress": 1, "appVersion": 2, "libVersion": 3, "tenantName": 4, ]
  }

  public static var structName: String { return "RpOpen" }

  public static func read(from proto: TProtocol) throws -> RpOpen {
    _ = try proto.readStructBegin()
    var remoteAddress: String!
    var appVersion: AppVersion!
    var libVersion: AppVersion!
    var tenantName: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           remoteAddress = try String.read(from: proto)
        case (2, .struct):           appVersion = try AppVersion.read(from: proto)
        case (3, .struct):           libVersion = try AppVersion.read(from: proto)
        case (4, .string):           tenantName = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(remoteAddress, named: "remoteAddress")
    try proto.validateValue(appVersion, named: "appVersion")
    try proto.validateValue(libVersion, named: "libVersion")
    try proto.validateValue(tenantName, named: "tenantName")

    return RpOpen(remoteAddress: remoteAddress, appVersion: appVersion, libVersion: libVersion, tenantName: tenantName)
  }

}



public func ==(lhs: AppAccount, rhs: AppAccount) -> Bool {
  return
    (lhs.name == rhs.name) &&
    (lhs.userName == rhs.userName) &&
    (lhs.tenantName == rhs.tenantName) &&
    (lhs.realmName == rhs.realmName) &&
    (lhs.fullQualifiedName == rhs.fullQualifiedName) &&
    (lhs.updatePushNotification == rhs.updatePushNotification) &&
    (lhs.usingReverseProxy == rhs.usingReverseProxy) &&
    (lhs.settingsFileName == rhs.settingsFileName)
}

extension AppAccount : CustomStringConvertible {

  public var description : String {
    var desc = "AppAccount("
    desc += "name=\(String(describing: self.name)), "
    desc += "userName=\(String(describing: self.userName)), "
    desc += "tenantName=\(String(describing: self.tenantName)), "
    desc += "realmName=\(String(describing: self.realmName)), "
    desc += "fullQualifiedName=\(String(describing: self.fullQualifiedName)), "
    desc += "updatePushNotification=\(String(describing: self.updatePushNotification)), "
    desc += "usingReverseProxy=\(String(describing: self.usingReverseProxy)), "
    desc += "settingsFileName=\(String(describing: self.settingsFileName))"
    return desc
  }

}

extension AppAccount : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (name.hashValue)
    result = prime &* result &+ (userName.hashValue)
    result = prime &* result &+ (tenantName.hashValue)
    result = prime &* result &+ (realmName.hashValue)
    result = prime &* result &+ (fullQualifiedName.hashValue)
    result = prime &* result &+ (updatePushNotification.hashValue)
    result = prime &* result &+ (usingReverseProxy.hashValue)
    result = prime &* result &+ (settingsFileName.hashValue)
    return result
  }

}

extension AppAccount : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["name": 1, "userName": 2, "tenantName": 3, "realmName": 4, "fullQualifiedName": 5, "updatePushNotification": 6, "usingReverseProxy": 7, "settingsFileName": 8, ]
  }

  public static var structName: String { return "AppAccount" }

  public static func read(from proto: TProtocol) throws -> AppAccount {
    _ = try proto.readStructBegin()
    var name: String!
    var userName: String!
    var tenantName: String!
    var realmName: String!
    var fullQualifiedName: String!
    var updatePushNotification: Bool!
    var usingReverseProxy: Bool!
    var settingsFileName: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           name = try String.read(from: proto)
        case (2, .string):           userName = try String.read(from: proto)
        case (3, .string):           tenantName = try String.read(from: proto)
        case (4, .string):           realmName = try String.read(from: proto)
        case (5, .string):           fullQualifiedName = try String.read(from: proto)
        case (6, .bool):            updatePushNotification = try Bool.read(from: proto)
        case (7, .bool):            usingReverseProxy = try Bool.read(from: proto)
        case (8, .string):           settingsFileName = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(name, named: "name")
    try proto.validateValue(userName, named: "userName")
    try proto.validateValue(tenantName, named: "tenantName")
    try proto.validateValue(realmName, named: "realmName")
    try proto.validateValue(fullQualifiedName, named: "fullQualifiedName")
    try proto.validateValue(updatePushNotification, named: "updatePushNotification")
    try proto.validateValue(usingReverseProxy, named: "usingReverseProxy")
    try proto.validateValue(settingsFileName, named: "settingsFileName")

    return AppAccount(name: name, userName: userName, tenantName: tenantName, realmName: realmName, fullQualifiedName: fullQualifiedName, updatePushNotification: updatePushNotification, usingReverseProxy: usingReverseProxy, settingsFileName: settingsFileName)
  }

}



public func ==(lhs: AppAccounts, rhs: AppAccounts) -> Bool {
  return
    (lhs.accounts == rhs.accounts)
}

extension AppAccounts : CustomStringConvertible {

  public var description : String {
    var desc = "AppAccounts("
    desc += "accounts=\(String(describing: self.accounts))"
    return desc
  }

}

extension AppAccounts : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (accounts.hashValue)
    return result
  }

}

extension AppAccounts : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["accounts": 1, ]
  }

  public static var structName: String { return "AppAccounts" }

  public static func read(from proto: TProtocol) throws -> AppAccounts {
    _ = try proto.readStructBegin()
    var accounts: TList<AppAccount>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            accounts = try TList<AppAccount>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(accounts, named: "accounts")

    return AppAccounts(accounts: accounts)
  }

}



public func ==(lhs: ProxyOpenParam, rhs: ProxyOpenParam) -> Bool {
  return
    (lhs.handle == rhs.handle) &&
    (lhs.ipHost == rhs.ipHost) &&
    (lhs.port == rhs.port) &&
    (lhs.secure == rhs.secure) &&
    (lhs.verifyCertificate == rhs.verifyCertificate) &&
    (lhs.dataWait == rhs.dataWait)
}

extension ProxyOpenParam : CustomStringConvertible {

  public var description : String {
    var desc = "ProxyOpenParam("
    desc += "handle=\(String(describing: self.handle)), "
    desc += "ipHost=\(String(describing: self.ipHost)), "
    desc += "port=\(String(describing: self.port)), "
    desc += "secure=\(String(describing: self.secure)), "
    desc += "verifyCertificate=\(String(describing: self.verifyCertificate)), "
    desc += "dataWait=\(String(describing: self.dataWait))"
    return desc
  }

}

extension ProxyOpenParam : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (handle.hashValue)
    result = prime &* result &+ (ipHost.hashValue)
    result = prime &* result &+ (port.hashValue)
    result = prime &* result &+ (secure.hashValue)
    result = prime &* result &+ (verifyCertificate.hashValue)
    result = prime &* result &+ (dataWait.hashValue)
    return result
  }

}

extension ProxyOpenParam : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["handle": 1, "ipHost": 2, "port": 3, "secure": 4, "verifyCertificate": 5, "dataWait": 6, ]
  }

  public static var structName: String { return "ProxyOpenParam" }

  public static func read(from proto: TProtocol) throws -> ProxyOpenParam {
    _ = try proto.readStructBegin()
    var handle: Int64!
    var ipHost: String!
    var port: Int32!
    var secure: Bool!
    var verifyCertificate: Bool!
    var dataWait: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i64):             handle = try Int64.read(from: proto)
        case (2, .string):           ipHost = try String.read(from: proto)
        case (3, .i32):             port = try Int32.read(from: proto)
        case (4, .bool):            secure = try Bool.read(from: proto)
        case (5, .bool):            verifyCertificate = try Bool.read(from: proto)
        case (6, .i32):             dataWait = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(handle, named: "handle")
    try proto.validateValue(ipHost, named: "ipHost")
    try proto.validateValue(port, named: "port")
    try proto.validateValue(secure, named: "secure")
    try proto.validateValue(verifyCertificate, named: "verifyCertificate")
    try proto.validateValue(dataWait, named: "dataWait")

    return ProxyOpenParam(handle: handle, ipHost: ipHost, port: port, secure: secure, verifyCertificate: verifyCertificate, dataWait: dataWait)
  }

}



extension AppSystemClient : AppSystem {

}

extension AppSystemProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = AppSystemProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

