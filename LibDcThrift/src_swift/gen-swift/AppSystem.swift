/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public enum CloudSafeOptions : TEnum {
  case enc
  case pwd

  public static func read(from proto: TProtocol) throws -> CloudSafeOptions {
    let raw: Int32 = try proto.read()
    let new = CloudSafeOptions(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(CloudSafeOptions.self)")
    }
  }

  public init() {
    self = .enc
  }

  public var rawValue: Int32 {
    switch self {
    case .enc: return 0
    case .pwd: return 1
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .enc
    case 1: self = .pwd
    default: return nil
    }
  }
}

public enum AppErrorCodes : TEnum {
  case ok
  case wrong_credentials
  case invalid_activation_code
  case activation_code_expired
  case user_password_max_retries
  case unknown_client_type
  case unknown_arch_type
  case reject_risk
  case update_necessary
  case invalid_userid
  case unexpected_error
  case invalid_version
  case invalid_pin
  case csr_signature
  case csr_error
  case transport_error
  case user_disabled
  case user_temporary_disabled
  case invalid_device_name
  case invalid_device_id
  case device_disabled
  case incorrect_state
  case invalid_udid
  case invalid_client_signature
  case no_template_found
  case response_message_error
  case client_error
  case response_message_invalid_id
  case invalid_password
  case duplicated_device_name
  case rest_add_message_failure
  case app_msg_response_timedout
  case invalid_message_signature
  case property_not_found
  case version_updated_required
  case version_disabled
  case fcm_pushnotification
  case invalid_cloud_safe_signature
  case cloud_safe_not_found
  case licence_expired
  case licence_max_user
  case invalid_domain_name
  case dispatcher_connection_to_dcem_failed
  case connection_to_ldap_failed
  case unregistered_dcem
  case no_connection_to_destination_dcem
  case not_a_dispatcher_proxy
  case domain_cannot_connect_to_itself
  case domain_has_no_configuration
  case reverse_proxy_connection_limit
  case invalid_device_key
  case invalid_offline_key
  case user_has_no_devices
  case no_distinct_user_name
  case invalid_passcode
  case passcode_not_numeric
  case invalid_auth_method
  case auth_method_not_allowed
  case no_auth_method_found
  case sms_user_has_no_mobile
  case sms_send_exception
  case send_voice_exception
  case invalid_otp
  case user_has_no_otp_tokens
  case invalid_tenant_identifier
  case user_has_no_telephone_or_mobile
  case invalid_cloud_safe_owner
  case app_msg_ignored
  case db_decrytion_error
  case no_write_access
  case reverse_proxy_redirection
  case password_safe_limit_reached
  case cloud_safe_limit_reached
  case password_safe_not_enabled
  case cloud_safe_global_limit_reached
  case cloud_safe_user_limit_reached
  case cloud_safe_user_expiry_date_reached
  case cloud_safe_file_decryption
  case licence_max_users_reached
  case licence_max_global_users_reached
  case invalid_file_safe_owner
  case clouddata_out_of_date
  case create_account_invalid_credentials
  case invalid_auth_session_cookie

  public static func read(from proto: TProtocol) throws -> AppErrorCodes {
    let raw: Int32 = try proto.read()
    let new = AppErrorCodes(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(AppErrorCodes.self)")
    }
  }

  public init() {
    self = .ok
  }

  public var rawValue: Int32 {
    switch self {
    case .ok: return 0
    case .wrong_credentials: return 1
    case .invalid_activation_code: return 2
    case .activation_code_expired: return 3
    case .user_password_max_retries: return 4
    case .unknown_client_type: return 5
    case .unknown_arch_type: return 6
    case .reject_risk: return 7
    case .update_necessary: return 8
    case .invalid_userid: return 9
    case .unexpected_error: return 10
    case .invalid_version: return 11
    case .invalid_pin: return 12
    case .csr_signature: return 13
    case .csr_error: return 14
    case .transport_error: return 15
    case .user_disabled: return 16
    case .user_temporary_disabled: return 17
    case .invalid_device_name: return 18
    case .invalid_device_id: return 19
    case .device_disabled: return 20
    case .incorrect_state: return 21
    case .invalid_udid: return 22
    case .invalid_client_signature: return 23
    case .no_template_found: return 24
    case .response_message_error: return 25
    case .client_error: return 26
    case .response_message_invalid_id: return 27
    case .invalid_password: return 28
    case .duplicated_device_name: return 29
    case .rest_add_message_failure: return 30
    case .app_msg_response_timedout: return 31
    case .invalid_message_signature: return 32
    case .property_not_found: return 33
    case .version_updated_required: return 34
    case .version_disabled: return 35
    case .fcm_pushnotification: return 36
    case .invalid_cloud_safe_signature: return 37
    case .cloud_safe_not_found: return 38
    case .licence_expired: return 39
    case .licence_max_user: return 40
    case .invalid_domain_name: return 41
    case .dispatcher_connection_to_dcem_failed: return 42
    case .connection_to_ldap_failed: return 43
    case .unregistered_dcem: return 44
    case .no_connection_to_destination_dcem: return 45
    case .not_a_dispatcher_proxy: return 46
    case .domain_cannot_connect_to_itself: return 47
    case .domain_has_no_configuration: return 48
    case .reverse_proxy_connection_limit: return 49
    case .invalid_device_key: return 50
    case .invalid_offline_key: return 51
    case .user_has_no_devices: return 52
    case .no_distinct_user_name: return 53
    case .invalid_passcode: return 54
    case .passcode_not_numeric: return 55
    case .invalid_auth_method: return 56
    case .auth_method_not_allowed: return 57
    case .no_auth_method_found: return 58
    case .sms_user_has_no_mobile: return 59
    case .sms_send_exception: return 60
    case .send_voice_exception: return 61
    case .invalid_otp: return 62
    case .user_has_no_otp_tokens: return 63
    case .invalid_tenant_identifier: return 64
    case .user_has_no_telephone_or_mobile: return 65
    case .invalid_cloud_safe_owner: return 66
    case .app_msg_ignored: return 67
    case .db_decrytion_error: return 68
    case .no_write_access: return 69
    case .reverse_proxy_redirection: return 70
    case .password_safe_limit_reached: return 71
    case .cloud_safe_limit_reached: return 72
    case .password_safe_not_enabled: return 73
    case .cloud_safe_global_limit_reached: return 74
    case .cloud_safe_user_limit_reached: return 75
    case .cloud_safe_user_expiry_date_reached: return 76
    case .cloud_safe_file_decryption: return 77
    case .licence_max_users_reached: return 78
    case .licence_max_global_users_reached: return 79
    case .invalid_file_safe_owner: return 80
    case .clouddata_out_of_date: return 81
    case .create_account_invalid_credentials: return 82
    case .invalid_auth_session_cookie: return 83
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .ok
    case 1: self = .wrong_credentials
    case 2: self = .invalid_activation_code
    case 3: self = .activation_code_expired
    case 4: self = .user_password_max_retries
    case 5: self = .unknown_client_type
    case 6: self = .unknown_arch_type
    case 7: self = .reject_risk
    case 8: self = .update_necessary
    case 9: self = .invalid_userid
    case 10: self = .unexpected_error
    case 11: self = .invalid_version
    case 12: self = .invalid_pin
    case 13: self = .csr_signature
    case 14: self = .csr_error
    case 15: self = .transport_error
    case 16: self = .user_disabled
    case 17: self = .user_temporary_disabled
    case 18: self = .invalid_device_name
    case 19: self = .invalid_device_id
    case 20: self = .device_disabled
    case 21: self = .incorrect_state
    case 22: self = .invalid_udid
    case 23: self = .invalid_client_signature
    case 24: self = .no_template_found
    case 25: self = .response_message_error
    case 26: self = .client_error
    case 27: self = .response_message_invalid_id
    case 28: self = .invalid_password
    case 29: self = .duplicated_device_name
    case 30: self = .rest_add_message_failure
    case 31: self = .app_msg_response_timedout
    case 32: self = .invalid_message_signature
    case 33: self = .property_not_found
    case 34: self = .version_updated_required
    case 35: self = .version_disabled
    case 36: self = .fcm_pushnotification
    case 37: self = .invalid_cloud_safe_signature
    case 38: self = .cloud_safe_not_found
    case 39: self = .licence_expired
    case 40: self = .licence_max_user
    case 41: self = .invalid_domain_name
    case 42: self = .dispatcher_connection_to_dcem_failed
    case 43: self = .connection_to_ldap_failed
    case 44: self = .unregistered_dcem
    case 45: self = .no_connection_to_destination_dcem
    case 46: self = .not_a_dispatcher_proxy
    case 47: self = .domain_cannot_connect_to_itself
    case 48: self = .domain_has_no_configuration
    case 49: self = .reverse_proxy_connection_limit
    case 50: self = .invalid_device_key
    case 51: self = .invalid_offline_key
    case 52: self = .user_has_no_devices
    case 53: self = .no_distinct_user_name
    case 54: self = .invalid_passcode
    case 55: self = .passcode_not_numeric
    case 56: self = .invalid_auth_method
    case 57: self = .auth_method_not_allowed
    case 58: self = .no_auth_method_found
    case 59: self = .sms_user_has_no_mobile
    case 60: self = .sms_send_exception
    case 61: self = .send_voice_exception
    case 62: self = .invalid_otp
    case 63: self = .user_has_no_otp_tokens
    case 64: self = .invalid_tenant_identifier
    case 65: self = .user_has_no_telephone_or_mobile
    case 66: self = .invalid_cloud_safe_owner
    case 67: self = .app_msg_ignored
    case 68: self = .db_decrytion_error
    case 69: self = .no_write_access
    case 70: self = .reverse_proxy_redirection
    case 71: self = .password_safe_limit_reached
    case 72: self = .cloud_safe_limit_reached
    case 73: self = .password_safe_not_enabled
    case 74: self = .cloud_safe_global_limit_reached
    case 75: self = .cloud_safe_user_limit_reached
    case 76: self = .cloud_safe_user_expiry_date_reached
    case 77: self = .cloud_safe_file_decryption
    case 78: self = .licence_max_users_reached
    case 79: self = .licence_max_global_users_reached
    case 80: self = .invalid_file_safe_owner
    case 81: self = .clouddata_out_of_date
    case 82: self = .create_account_invalid_credentials
    case 83: self = .invalid_auth_session_cookie
    default: return nil
    }
  }
}

public enum CommClientType : TEnum {
  case app
  case dcem_as_client
  case auth_app

  public static func read(from proto: TProtocol) throws -> CommClientType {
    let raw: Int32 = try proto.read()
    let new = CommClientType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(CommClientType.self)")
    }
  }

  public init() {
    self = .app
  }

  public var rawValue: Int32 {
    switch self {
    case .app: return 1
    case .dcem_as_client: return 2
    case .auth_app: return 3
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .app
    case 2: self = .dcem_as_client
    case 3: self = .auth_app
    default: return nil
    }
  }
}

public enum MsgPriority : TEnum {
  case immediate
  case urgent
  case high
  case noraml
  case low
  case negligible
  case `none`

  public static func read(from proto: TProtocol) throws -> MsgPriority {
    let raw: Int32 = try proto.read()
    let new = MsgPriority(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(MsgPriority.self)")
    }
  }

  public init() {
    self = .immediate
  }

  public var rawValue: Int32 {
    switch self {
    case .immediate: return 1
    case .urgent: return 2
    case .high: return 3
    case .noraml: return 4
    case .low: return 5
    case .negligible: return 6
    case .`none`: return 7
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 1: self = .immediate
    case 2: self = .urgent
    case 3: self = .high
    case 4: self = .noraml
    case 5: self = .low
    case 6: self = .negligible
    case 7: self = .`none`
    default: return nil
    }
  }
}

public enum ThriftAuthMethod : TEnum {
  case auto
  case password
  case sms
  case voice_message
  case hardware_token
  case doubleclue_passcode
  case push_approval
  case qrcode_approval
  case session_reconnect
  case fido_u2f

  public static func read(from proto: TProtocol) throws -> ThriftAuthMethod {
    let raw: Int32 = try proto.read()
    let new = ThriftAuthMethod(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(ThriftAuthMethod.self)")
    }
  }

  public init() {
    self = .auto
  }

  public var rawValue: Int32 {
    switch self {
    case .auto: return -1
    case .password: return 0
    case .sms: return 1
    case .voice_message: return 2
    case .hardware_token: return 3
    case .doubleclue_passcode: return 4
    case .push_approval: return 5
    case .qrcode_approval: return 6
    case .session_reconnect: return 7
    case .fido_u2f: return 8
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case -1: self = .auto
    case 0: self = .password
    case 1: self = .sms
    case 2: self = .voice_message
    case 3: self = .hardware_token
    case 4: self = .doubleclue_passcode
    case 5: self = .push_approval
    case 6: self = .qrcode_approval
    case 7: self = .session_reconnect
    case 8: self = .fido_u2f
    default: return nil
    }
  }
}

public enum ClientType : TEnum {
  case android
  case i_os
  case windows
  case mac
  case linux

  public static func read(from proto: TProtocol) throws -> ClientType {
    let raw: Int32 = try proto.read()
    let new = ClientType(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(ClientType.self)")
    }
  }

  public init() {
    self = .android
  }

  public var rawValue: Int32 {
    switch self {
    case .android: return 0
    case .i_os: return 1
    case .windows: return 2
    case .mac: return 3
    case .linux: return 4
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .android
    case 1: self = .i_os
    case 2: self = .windows
    case 3: self = .mac
    case 4: self = .linux
    default: return nil
    }
  }
}

public enum CpuArch : TEnum {
  case unknown
  case x86
  case asm

  public static func read(from proto: TProtocol) throws -> CpuArch {
    let raw: Int32 = try proto.read()
    let new = CpuArch(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(CpuArch.self)")
    }
  }

  public init() {
    self = .unknown
  }

  public var rawValue: Int32 {
    switch self {
    case .unknown: return 0
    case .x86: return 1
    case .asm: return 2
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .x86
    case 2: self = .asm
    default: return nil
    }
  }
}

public enum CloudSafeOwner : TEnum {
  case global
  case user
  case device

  public static func read(from proto: TProtocol) throws -> CloudSafeOwner {
    let raw: Int32 = try proto.read()
    let new = CloudSafeOwner(rawValue: raw)
    if let unwrapped = new {
      return unwrapped
    } else {
      throw TProtocolError(error: .invalidData,
                           message: "Invalid enum value (\(raw)) for \(CloudSafeOwner.self)")
    }
  }

  public init() {
    self = .global
  }

  public var rawValue: Int32 {
    switch self {
    case .global: return 0
    case .user: return 1
    case .device: return 2
    }
  }

  public init?(rawValue: Int32) {
    switch rawValue {
    case 0: self = .global
    case 1: self = .user
    case 2: self = .device
    default: return nil
    }
  }
}

public final class AppException : Swift.Error {

  public var error: String

  public var info: String?


  public init(error: String) {
    self.error = error
  }

  public init(error: String, info: String?) {
    self.error = error
    self.info = info
  }

}

public final class SdkConfig {

  public var connectionKey: Data

  public var serverUrl: String

  public var transportProtocol: String

  public var serverPublicKey: Data

  public var portalUrl: String?


  public init(connectionKey: Data, serverUrl: String, transportProtocol: String, serverPublicKey: Data) {
    self.connectionKey = connectionKey
    self.serverUrl = serverUrl
    self.transportProtocol = transportProtocol
    self.serverPublicKey = serverPublicKey
  }

  public init(connectionKey: Data, serverUrl: String, transportProtocol: String, serverPublicKey: Data, portalUrl: String?) {
    self.connectionKey = connectionKey
    self.serverUrl = serverUrl
    self.transportProtocol = transportProtocol
    self.serverPublicKey = serverPublicKey
    self.portalUrl = portalUrl
  }

}

public final class AuthGatewayConfig {

  public var name: String

  public var sharedSecret: Data

  public var tenantName: String


  public init(name: String, sharedSecret: Data, tenantName: String) {
    self.name = name
    self.sharedSecret = sharedSecret
    self.tenantName = tenantName
  }

}

public final class SdkSettings {

  public var deviceId: Int32

  public var userId: String

  public var deviceName: String

  public var privateKey: Data

  public var publicKey: Data

  public var offlineKey: Data

  public var passcodeValidFor: Int32

  public var safe: TMap<String, String>

  public var sessionCookie: Data

  public var sessionCookieExpiresOn: Int32


  public init(deviceId: Int32, userId: String, deviceName: String, privateKey: Data, publicKey: Data, offlineKey: Data, passcodeValidFor: Int32, safe: TMap<String, String>, sessionCookie: Data, sessionCookieExpiresOn: Int32) {
    self.deviceId = deviceId
    self.userId = userId
    self.deviceName = deviceName
    self.privateKey = privateKey
    self.publicKey = publicKey
    self.offlineKey = offlineKey
    self.passcodeValidFor = passcodeValidFor
    self.safe = safe
    self.sessionCookie = sessionCookie
    self.sessionCookieExpiresOn = sessionCookieExpiresOn
  }

}

public final class MsgAttachment {

  public var id: Int64

  public var name: String

  public var mimeType: String

  public var size: Int32


  public init(id: Int64, name: String, mimeType: String, size: Int32) {
    self.id = id
    self.name = name
    self.mimeType = mimeType
    self.size = size
  }

}

public final class AppMessage {

  public var id: Int64

  public var priority: MsgPriority

  public var templateId: Int32

  public var signitureRequired: Bool

  public var responseRequired: Bool

  public var responseTime: Int32

  public var responseTo: Int64

  public var data: TMap<String, String>


  public init(id: Int64, priority: MsgPriority, templateId: Int32, signitureRequired: Bool, responseRequired: Bool, responseTime: Int32, responseTo: Int64, data: TMap<String, String>) {
    self.id = id
    self.priority = priority
    self.templateId = templateId
    self.signitureRequired = signitureRequired
    self.responseRequired = responseRequired
    self.responseTime = responseTime
    self.responseTo = responseTo
    self.data = data
  }

}

public final class AppMessageResponse {

  public var id: Int64

  public var actionId: String

  public var errorCode: AppErrorCodes

  public var errorMessage: String

  public var read: Bool

  public var responseData: TMap<String, String>

  public var signature: Data?


  public init(id: Int64, actionId: String, errorCode: AppErrorCodes, errorMessage: String, read: Bool, responseData: TMap<String, String>) {
    self.id = id
    self.actionId = actionId
    self.errorCode = errorCode
    self.errorMessage = errorMessage
    self.read = read
    self.responseData = responseData
  }

  public init(id: Int64, actionId: String, errorCode: AppErrorCodes, errorMessage: String, read: Bool, responseData: TMap<String, String>, signature: Data?) {
    self.id = id
    self.actionId = actionId
    self.errorCode = errorCode
    self.errorMessage = errorMessage
    self.read = read
    self.responseData = responseData
    self.signature = signature
  }

}

public final class AuthAppMessageResponse {

  public var succesful: Bool

  public var errorCode: String?

  public var errorMessage: String?

  public var userKey: Data?

  public var sessionCookieExpiresOn: Int32?

  public var sessionCookie: String?

  public var msgId: Int64


  public init(succesful: Bool, msgId: Int64) {
    self.succesful = succesful
    self.msgId = msgId
  }

  public init(succesful: Bool, errorCode: String?, errorMessage: String?, userKey: Data?, sessionCookieExpiresOn: Int32?, sessionCookie: String?, msgId: Int64) {
    self.succesful = succesful
    self.errorCode = errorCode
    self.errorMessage = errorMessage
    self.userKey = userKey
    self.sessionCookieExpiresOn = sessionCookieExpiresOn
    self.sessionCookie = sessionCookie
    self.msgId = msgId
  }

}

public final class AppVersion {

  public var version: Int32

  public var name: String

  public var state: String


  public init(version: Int32, name: String, state: String) {
    self.version = version
    self.name = name
    self.state = state
  }

}

public final class Template {

  public var id: Int32

  public var name: String

  public var locale: String

  public var content: String?


  public init(id: Int32, name: String, locale: String) {
    self.id = id
    self.name = name
    self.locale = locale
  }

  public init(id: Int32, name: String, locale: String, content: String?) {
    self.id = id
    self.name = name
    self.locale = locale
    self.content = content
  }

}

public final class SdkCloudSafeKey {

  public var owner: CloudSafeOwner

  public var name: String


  public init(owner: CloudSafeOwner, name: String) {
    self.owner = owner
    self.name = name
  }

}

public final class SdkCloudSafe {

  public var uniqueKey: SdkCloudSafeKey

  public var content: Data

  public var options: String

  public var discardAfter: Int64

  public var lastModified: Int64

  public var signature: Data

  public var length: Int64

  public var sharedUser: String

  public var writeAccess: Bool


  public init(uniqueKey: SdkCloudSafeKey, content: Data, options: String, discardAfter: Int64, lastModified: Int64, signature: Data, length: Int64, sharedUser: String, writeAccess: Bool) {
    self.uniqueKey = uniqueKey
    self.content = content
    self.options = options
    self.discardAfter = discardAfter
    self.lastModified = lastModified
    self.signature = signature
    self.length = length
    self.sharedUser = sharedUser
    self.writeAccess = writeAccess
  }

}

public final class User {

  public var loginId: String

  public var updatePushNotification: Bool

  public var usingReverseProxy: Bool


  public init(loginId: String, updatePushNotification: Bool, usingReverseProxy: Bool) {
    self.loginId = loginId
    self.updatePushNotification = updatePushNotification
    self.usingReverseProxy = usingReverseProxy
  }

}

public final class ActivatedUsers {

  public var users: TList<User>


  public init(users: TList<User>) {
    self.users = users
  }

}

public final class RpOpen {

  public var remoteAddress: String

  public var appVersion: AppVersion

  public var libVersion: AppVersion

  public var tenantName: String


  public init(remoteAddress: String, appVersion: AppVersion, libVersion: AppVersion, tenantName: String) {
    self.remoteAddress = remoteAddress
    self.appVersion = appVersion
    self.libVersion = libVersion
    self.tenantName = tenantName
  }

}

public final class AppAccount {

  public var name: String

  public var userName: String

  public var tenantName: String

  public var realmName: String

  public var fullQualifiedName: String

  public var updatePushNotification: Bool

  public var usingReverseProxy: Bool

  public var settingsFileName: String


  public init(name: String, userName: String, tenantName: String, realmName: String, fullQualifiedName: String, updatePushNotification: Bool, usingReverseProxy: Bool, settingsFileName: String) {
    self.name = name
    self.userName = userName
    self.tenantName = tenantName
    self.realmName = realmName
    self.fullQualifiedName = fullQualifiedName
    self.updatePushNotification = updatePushNotification
    self.usingReverseProxy = usingReverseProxy
    self.settingsFileName = settingsFileName
  }

}

public final class AppAccounts {

  public var accounts: TList<AppAccount>


  public init(accounts: TList<AppAccount>) {
    self.accounts = accounts
  }

}

public final class ProxyOpenParam {

  public var handle: Int64

  public var ipHost: String

  public var port: Int32

  public var secure: Bool

  public var verifyCertificate: Bool

  public var dataWait: Int32


  public init(handle: Int64, ipHost: String, port: Int32, secure: Bool, verifyCertificate: Bool, dataWait: Int32) {
    self.handle = handle
    self.ipHost = ipHost
    self.port = port
    self.secure = secure
    self.verifyCertificate = verifyCertificate
    self.dataWait = dataWait
  }

}

public protocol AppSystem {

}

open class AppSystemClient : TClient /* , AppSystem */ {

}

open class AppSystemProcessor /* AppSystem */ {

  typealias ProcessorHandlerDictionary = [String: (Int32, TProtocol, TProtocol, AppSystem) throws -> Void]

  public var service: AppSystem

  public required init(service: AppSystem) {
    self.service = service
  }

}

public let PROTOCOL_VERSION : Int8 = Int8(49)

public let PROTOCOL_APP_TO_SERVER : Int8 = Int8(65)

public let PROTOCOL_SERVER_TO_APP : Int8 = Int8(83)

public let PROTOCOL_REVERSE_PROXY : Int8 = Int8(66)

public let REVERSE_PROXY_OPEN : Int8 = Int8(1)

public let REVERSE_PROXY_CLOSE : Int8 = Int8(2)

public let REVERSE_PROXY_DATA : Int8 = Int8(3)

public let SIGNATURE_STRING : String = "This is the SEM-DoubleCheck signature. This is user to verify the signatures"

public let DcemFileName : String = "SdkConfig.dcem"

public let SdkConfigFileName : String = "SdkConfig.as"

public let SignatureFileName : String = "SdkConfig.sig"

public let TrustStoreFileName : String = "TrustStore.pem"

public let AuthConnectorFileName : String = "AuthConnector.dcem"

public let UserFullQualifiedId : String = "userFqID"

public let PasswordLessLogin : String = "passwordLessLogin"

public let PushNotificationTitle : String = "pntitle"

public let PushNotificationBody : String = "pnBody"

public let PushNotificationAction : String = "pnAction"

public let TENANT_SEPERATOR : String = "!"

public let REALM_SEPERATOR : String = "$"

public let PUSH_NOTIFICATION_TOKEN : String = "hws.pushnotification.token"

public let AUTH_PARAM_UNLOCK : String = "unlock"

public let AUTH_PARAM_USE_ALTERNATIVES : String = "useAlternatives"

public let TRUE_VALUE : String = "true"


