/**
 * Autogenerated by Thrift Compiler (0.13.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */

import Foundation

import Thrift


public func ==(lhs: ServerSignatureParam, rhs: ServerSignatureParam) -> Bool {
  return
    (lhs.dataForSignature == rhs.dataForSignature) &&
    (lhs.appVersion == rhs.appVersion) &&
    (lhs.libVersion == rhs.libVersion) &&
    (lhs.domainName == rhs.domainName) &&
    (lhs.iamDcem == rhs.iamDcem) &&
    (lhs.commClientType == rhs.commClientType)
}

extension ServerSignatureParam : CustomStringConvertible {

  public var description : String {
    var desc = "ServerSignatureParam("
    desc += "dataForSignature=\(String(describing: self.dataForSignature)), "
    desc += "appVersion=\(String(describing: self.appVersion)), "
    desc += "libVersion=\(String(describing: self.libVersion)), "
    desc += "domainName=\(String(describing: self.domainName)), "
    desc += "iamDcem=\(String(describing: self.iamDcem)), "
    desc += "commClientType=\(String(describing: self.commClientType))"
    return desc
  }

}

extension ServerSignatureParam : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (dataForSignature.hashValue)
    result = prime &* result &+ (appVersion.hashValue)
    result = prime &* result &+ (libVersion.hashValue)
    result = prime &* result &+ (domainName.hashValue)
    result = prime &* result &+ (iamDcem.hashValue)
    result = prime &* result &+ (commClientType.hashValue)
    return result
  }

}

extension ServerSignatureParam : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["dataForSignature": 1, "appVersion": 2, "libVersion": 3, "domainName": 4, "iamDcem": 5, "commClientType": 6, ]
  }

  public static var structName: String { return "ServerSignatureParam" }

  public static func read(from proto: TProtocol) throws -> ServerSignatureParam {
    _ = try proto.readStructBegin()
    var dataForSignature: Data!
    var appVersion: AppVersion!
    var libVersion: AppVersion!
    var domainName: String!
    var iamDcem: Bool!
    var commClientType: CommClientType!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           dataForSignature = try Data.read(from: proto)
        case (2, .struct):           appVersion = try AppVersion.read(from: proto)
        case (3, .struct):           libVersion = try AppVersion.read(from: proto)
        case (4, .string):           domainName = try String.read(from: proto)
        case (5, .bool):            iamDcem = try Bool.read(from: proto)
        case (6, .i32):             commClientType = try CommClientType.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(dataForSignature, named: "dataForSignature")
    try proto.validateValue(appVersion, named: "appVersion")
    try proto.validateValue(libVersion, named: "libVersion")
    try proto.validateValue(domainName, named: "domainName")
    try proto.validateValue(iamDcem, named: "iamDcem")
    try proto.validateValue(commClientType, named: "commClientType")

    return ServerSignatureParam(dataForSignature: dataForSignature, appVersion: appVersion, libVersion: libVersion, domainName: domainName, iamDcem: iamDcem, commClientType: commClientType)
  }

}



public func ==(lhs: ServerSignatureResponse, rhs: ServerSignatureResponse) -> Bool {
  return
    (lhs.serverSignature == rhs.serverSignature) &&
    (lhs.serverVersion == rhs.serverVersion) &&
    (lhs.isReverseProxy == rhs.isReverseProxy) &&
    (lhs.isDispatched == rhs.isDispatched) &&
    (lhs.challenge == rhs.challenge)
}

extension ServerSignatureResponse : CustomStringConvertible {

  public var description : String {
    var desc = "ServerSignatureResponse("
    desc += "serverSignature=\(String(describing: self.serverSignature)), "
    desc += "serverVersion=\(String(describing: self.serverVersion)), "
    desc += "isReverseProxy=\(String(describing: self.isReverseProxy)), "
    desc += "isDispatched=\(String(describing: self.isDispatched)), "
    desc += "challenge=\(String(describing: self.challenge))"
    return desc
  }

}

extension ServerSignatureResponse : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (serverSignature.hashValue)
    result = prime &* result &+ (serverVersion.hashValue)
    result = prime &* result &+ (isReverseProxy.hashValue)
    result = prime &* result &+ (isDispatched.hashValue)
    result = prime &* result &+ (challenge?.hashValue ?? 0)
    return result
  }

}

extension ServerSignatureResponse : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["serverSignature": 1, "serverVersion": 2, "isReverseProxy": 3, "isDispatched": 4, "challenge": 5, ]
  }

  public static var structName: String { return "ServerSignatureResponse" }

  public static func read(from proto: TProtocol) throws -> ServerSignatureResponse {
    _ = try proto.readStructBegin()
    var serverSignature: Data!
    var serverVersion: AppVersion!
    var isReverseProxy: Bool!
    var isDispatched: Bool!
    var challenge: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           serverSignature = try Data.read(from: proto)
        case (2, .struct):           serverVersion = try AppVersion.read(from: proto)
        case (3, .bool):            isReverseProxy = try Bool.read(from: proto)
        case (4, .bool):            isDispatched = try Bool.read(from: proto)
        case (5, .string):           challenge = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(serverSignature, named: "serverSignature")
    try proto.validateValue(serverVersion, named: "serverVersion")
    try proto.validateValue(isReverseProxy, named: "isReverseProxy")
    try proto.validateValue(isDispatched, named: "isDispatched")

    return ServerSignatureResponse(serverSignature: serverSignature, serverVersion: serverVersion, isReverseProxy: isReverseProxy, isDispatched: isDispatched, challenge: challenge)
  }

}



public func ==(lhs: DomainSdkConfigParam, rhs: DomainSdkConfigParam) -> Bool {
  return
    (lhs.domainName == rhs.domainName) &&
    (lhs.activationCode == rhs.activationCode) &&
    (lhs.userId == rhs.userId) &&
    (lhs.dispatcherSignature == rhs.dispatcherSignature)
}

extension DomainSdkConfigParam : CustomStringConvertible {

  public var description : String {
    var desc = "DomainSdkConfigParam("
    desc += "domainName=\(String(describing: self.domainName)), "
    desc += "activationCode=\(String(describing: self.activationCode)), "
    desc += "userId=\(String(describing: self.userId)), "
    desc += "dispatcherSignature=\(String(describing: self.dispatcherSignature))"
    return desc
  }

}

extension DomainSdkConfigParam : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (domainName.hashValue)
    result = prime &* result &+ (activationCode.hashValue)
    result = prime &* result &+ (userId.hashValue)
    result = prime &* result &+ (dispatcherSignature?.hashValue ?? 0)
    return result
  }

}

extension DomainSdkConfigParam : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["domainName": 1, "activationCode": 2, "userId": 3, "dispatcherSignature": 4, ]
  }

  public static var structName: String { return "DomainSdkConfigParam" }

  public static func read(from proto: TProtocol) throws -> DomainSdkConfigParam {
    _ = try proto.readStructBegin()
    var domainName: String!
    var activationCode: String!
    var userId: String!
    var dispatcherSignature: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           domainName = try String.read(from: proto)
        case (2, .string):           activationCode = try String.read(from: proto)
        case (3, .string):           userId = try String.read(from: proto)
        case (4, .string):           dispatcherSignature = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(domainName, named: "domainName")
    try proto.validateValue(activationCode, named: "activationCode")
    try proto.validateValue(userId, named: "userId")

    return DomainSdkConfigParam(domainName: domainName, activationCode: activationCode, userId: userId, dispatcherSignature: dispatcherSignature)
  }

}



public func ==(lhs: DomainSdkConfigResponse, rhs: DomainSdkConfigResponse) -> Bool {
  return
    (lhs.sdkConfigDcem == rhs.sdkConfigDcem)
}

extension DomainSdkConfigResponse : CustomStringConvertible {

  public var description : String {
    var desc = "DomainSdkConfigResponse("
    desc += "sdkConfigDcem=\(String(describing: self.sdkConfigDcem))"
    return desc
  }

}

extension DomainSdkConfigResponse : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (sdkConfigDcem?.hashValue ?? 0)
    return result
  }

}

extension DomainSdkConfigResponse : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["sdkConfigDcem": 1, ]
  }

  public static var structName: String { return "DomainSdkConfigResponse" }

  public static func read(from proto: TProtocol) throws -> DomainSdkConfigResponse {
    _ = try proto.readStructBegin()
    var sdkConfigDcem: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           sdkConfigDcem = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return DomainSdkConfigResponse(sdkConfigDcem: sdkConfigDcem)
  }

}



public func ==(lhs: RegisterDispatcherParam, rhs: RegisterDispatcherParam) -> Bool {
  return
    (lhs.domainName == rhs.domainName) &&
    (lhs.dispatcherSignature == rhs.dispatcherSignature) &&
    (lhs.pnKey == rhs.pnKey)
}

extension RegisterDispatcherParam : CustomStringConvertible {

  public var description : String {
    var desc = "RegisterDispatcherParam("
    desc += "domainName=\(String(describing: self.domainName)), "
    desc += "dispatcherSignature=\(String(describing: self.dispatcherSignature)), "
    desc += "pnKey=\(String(describing: self.pnKey))"
    return desc
  }

}

extension RegisterDispatcherParam : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (domainName.hashValue)
    result = prime &* result &+ (dispatcherSignature.hashValue)
    result = prime &* result &+ (pnKey.hashValue)
    return result
  }

}

extension RegisterDispatcherParam : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["domainName": 1, "dispatcherSignature": 2, "pnKey": 3, ]
  }

  public static var structName: String { return "RegisterDispatcherParam" }

  public static func read(from proto: TProtocol) throws -> RegisterDispatcherParam {
    _ = try proto.readStructBegin()
    var domainName: String!
    var dispatcherSignature: Data!
    var pnKey: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           domainName = try String.read(from: proto)
        case (2, .string):           dispatcherSignature = try Data.read(from: proto)
        case (3, .string):           pnKey = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(domainName, named: "domainName")
    try proto.validateValue(dispatcherSignature, named: "dispatcherSignature")
    try proto.validateValue(pnKey, named: "pnKey")

    return RegisterDispatcherParam(domainName: domainName, dispatcherSignature: dispatcherSignature, pnKey: pnKey)
  }

}



public func ==(lhs: RegisterDispatcherResponse, rhs: RegisterDispatcherResponse) -> Bool {
  return
    (lhs.clusterId == rhs.clusterId)
}

extension RegisterDispatcherResponse : CustomStringConvertible {

  public var description : String {
    var desc = "RegisterDispatcherResponse("
    desc += "clusterId=\(String(describing: self.clusterId))"
    return desc
  }

}

extension RegisterDispatcherResponse : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (clusterId.hashValue)
    return result
  }

}

extension RegisterDispatcherResponse : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["clusterId": 1, ]
  }

  public static var structName: String { return "RegisterDispatcherResponse" }

  public static func read(from proto: TProtocol) throws -> RegisterDispatcherResponse {
    _ = try proto.readStructBegin()
    var clusterId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           clusterId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(clusterId, named: "clusterId")

    return RegisterDispatcherResponse(clusterId: clusterId)
  }

}



public func ==(lhs: ActivationParam, rhs: ActivationParam) -> Bool {
  return
    (lhs.activationCode == rhs.activationCode) &&
    (lhs.userId == rhs.userId) &&
    (lhs.udid == rhs.udid) &&
    (lhs.encPassword == rhs.encPassword) &&
    (lhs.cpuArch == rhs.cpuArch) &&
    (lhs.osVersion == rhs.osVersion) &&
    (lhs.locale == rhs.locale) &&
    (lhs.manufacture == rhs.manufacture) &&
    (lhs.deviceModel == rhs.deviceModel) &&
    (lhs.deviceName == rhs.deviceName) &&
    (lhs.publicKey == rhs.publicKey) &&
    (lhs.signature == rhs.signature) &&
    (lhs.clientType == rhs.clientType) &&
    (lhs.digest == rhs.digest) &&
    (lhs.risk == rhs.risk)
}

extension ActivationParam : CustomStringConvertible {

  public var description : String {
    var desc = "ActivationParam("
    desc += "activationCode=\(String(describing: self.activationCode)), "
    desc += "userId=\(String(describing: self.userId)), "
    desc += "udid=\(String(describing: self.udid)), "
    desc += "encPassword=\(String(describing: self.encPassword)), "
    desc += "cpuArch=\(String(describing: self.cpuArch)), "
    desc += "osVersion=\(String(describing: self.osVersion)), "
    desc += "locale=\(String(describing: self.locale)), "
    desc += "manufacture=\(String(describing: self.manufacture)), "
    desc += "deviceModel=\(String(describing: self.deviceModel)), "
    desc += "deviceName=\(String(describing: self.deviceName)), "
    desc += "publicKey=\(String(describing: self.publicKey)), "
    desc += "signature=\(String(describing: self.signature)), "
    desc += "clientType=\(String(describing: self.clientType)), "
    desc += "digest=\(String(describing: self.digest)), "
    desc += "risk=\(String(describing: self.risk))"
    return desc
  }

}

extension ActivationParam : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (activationCode.hashValue)
    result = prime &* result &+ (userId.hashValue)
    result = prime &* result &+ (udid.hashValue)
    result = prime &* result &+ (encPassword.hashValue)
    result = prime &* result &+ (cpuArch.hashValue)
    result = prime &* result &+ (osVersion.hashValue)
    result = prime &* result &+ (locale.hashValue)
    result = prime &* result &+ (manufacture.hashValue)
    result = prime &* result &+ (deviceModel.hashValue)
    result = prime &* result &+ (deviceName.hashValue)
    result = prime &* result &+ (publicKey.hashValue)
    result = prime &* result &+ (signature.hashValue)
    result = prime &* result &+ (clientType.hashValue)
    result = prime &* result &+ (digest?.hashValue ?? 0)
    result = prime &* result &+ (risk?.hashValue ?? 0)
    return result
  }

}

extension ActivationParam : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["activationCode": 1, "userId": 2, "udid": 3, "encPassword": 4, "cpuArch": 5, "osVersion": 6, "locale": 7, "manufacture": 8, "deviceModel": 9, "deviceName": 10, "publicKey": 11, "signature": 12, "clientType": 13, "digest": 14, "risk": 15, ]
  }

  public static var structName: String { return "ActivationParam" }

  public static func read(from proto: TProtocol) throws -> ActivationParam {
    _ = try proto.readStructBegin()
    var activationCode: String!
    var userId: String!
    var udid: Data!
    var encPassword: Data!
    var cpuArch: CpuArch!
    var osVersion: String!
    var locale: String!
    var manufacture: String!
    var deviceModel: String!
    var deviceName: String!
    var publicKey: Data!
    var signature: Data!
    var clientType: ClientType!
    var digest: Data?
    var risk: Data?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           activationCode = try String.read(from: proto)
        case (2, .string):           userId = try String.read(from: proto)
        case (3, .string):           udid = try Data.read(from: proto)
        case (4, .string):           encPassword = try Data.read(from: proto)
        case (5, .i32):             cpuArch = try CpuArch.read(from: proto)
        case (6, .string):           osVersion = try String.read(from: proto)
        case (7, .string):           locale = try String.read(from: proto)
        case (8, .string):           manufacture = try String.read(from: proto)
        case (9, .string):           deviceModel = try String.read(from: proto)
        case (10, .string):           deviceName = try String.read(from: proto)
        case (11, .string):           publicKey = try Data.read(from: proto)
        case (12, .string):           signature = try Data.read(from: proto)
        case (13, .i32):             clientType = try ClientType.read(from: proto)
        case (14, .string):           digest = try Data.read(from: proto)
        case (15, .string):           risk = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(activationCode, named: "activationCode")
    try proto.validateValue(userId, named: "userId")
    try proto.validateValue(udid, named: "udid")
    try proto.validateValue(encPassword, named: "encPassword")
    try proto.validateValue(cpuArch, named: "cpuArch")
    try proto.validateValue(osVersion, named: "osVersion")
    try proto.validateValue(locale, named: "locale")
    try proto.validateValue(manufacture, named: "manufacture")
    try proto.validateValue(deviceModel, named: "deviceModel")
    try proto.validateValue(deviceName, named: "deviceName")
    try proto.validateValue(publicKey, named: "publicKey")
    try proto.validateValue(signature, named: "signature")
    try proto.validateValue(clientType, named: "clientType")

    return ActivationParam(activationCode: activationCode, userId: userId, udid: udid, encPassword: encPassword, cpuArch: cpuArch, osVersion: osVersion, locale: locale, manufacture: manufacture, deviceModel: deviceModel, deviceName: deviceName, publicKey: publicKey, signature: signature, clientType: clientType, digest: digest, risk: risk)
  }

}



public func ==(lhs: ActivationResponse, rhs: ActivationResponse) -> Bool {
  return
    (lhs.updateAvailable == rhs.updateAvailable) &&
    (lhs.deviceId == rhs.deviceId) &&
    (lhs.signedCertificate == rhs.signedCertificate) &&
    (lhs.deviceKey == rhs.deviceKey) &&
    (lhs.offlineKey == rhs.offlineKey) &&
    (lhs.deviceName == rhs.deviceName)
}

extension ActivationResponse : CustomStringConvertible {

  public var description : String {
    var desc = "ActivationResponse("
    desc += "updateAvailable=\(String(describing: self.updateAvailable)), "
    desc += "deviceId=\(String(describing: self.deviceId)), "
    desc += "signedCertificate=\(String(describing: self.signedCertificate)), "
    desc += "deviceKey=\(String(describing: self.deviceKey)), "
    desc += "offlineKey=\(String(describing: self.offlineKey)), "
    desc += "deviceName=\(String(describing: self.deviceName))"
    return desc
  }

}

extension ActivationResponse : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (updateAvailable.hashValue)
    result = prime &* result &+ (deviceId.hashValue)
    result = prime &* result &+ (signedCertificate.hashValue)
    result = prime &* result &+ (deviceKey.hashValue)
    result = prime &* result &+ (offlineKey.hashValue)
    result = prime &* result &+ (deviceName.hashValue)
    return result
  }

}

extension ActivationResponse : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["updateAvailable": 1, "deviceId": 2, "signedCertificate": 3, "deviceKey": 4, "offlineKey": 5, "deviceName": 6, ]
  }

  public static var structName: String { return "ActivationResponse" }

  public static func read(from proto: TProtocol) throws -> ActivationResponse {
    _ = try proto.readStructBegin()
    var updateAvailable: Bool!
    var deviceId: Int32!
    var signedCertificate: Data!
    var deviceKey: Data!
    var offlineKey: Data!
    var deviceName: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .bool):            updateAvailable = try Bool.read(from: proto)
        case (2, .i32):             deviceId = try Int32.read(from: proto)
        case (3, .string):           signedCertificate = try Data.read(from: proto)
        case (4, .string):           deviceKey = try Data.read(from: proto)
        case (5, .string):           offlineKey = try Data.read(from: proto)
        case (6, .string):           deviceName = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(updateAvailable, named: "updateAvailable")
    try proto.validateValue(deviceId, named: "deviceId")
    try proto.validateValue(signedCertificate, named: "signedCertificate")
    try proto.validateValue(deviceKey, named: "deviceKey")
    try proto.validateValue(offlineKey, named: "offlineKey")
    try proto.validateValue(deviceName, named: "deviceName")

    return ActivationResponse(updateAvailable: updateAvailable, deviceId: deviceId, signedCertificate: signedCertificate, deviceKey: deviceKey, offlineKey: offlineKey, deviceName: deviceName)
  }

}



public func ==(lhs: LoginParam, rhs: LoginParam) -> Bool {
  return
    (lhs.deviceId == rhs.deviceId) &&
    (lhs.udid == rhs.udid) &&
    (lhs.encPassword == rhs.encPassword) &&
    (lhs.osVersion == rhs.osVersion) &&
    (lhs.locale == rhs.locale) &&
    (lhs.hotpCounter == rhs.hotpCounter) &&
    (lhs.digest == rhs.digest) &&
    (lhs.risk == rhs.risk) &&
    (lhs.passwordLess == rhs.passwordLess) &&
    (lhs.cpuArch == rhs.cpuArch) &&
    (lhs.commClientType == rhs.commClientType) &&
    (lhs.sessionCookie == rhs.sessionCookie)
}

extension LoginParam : CustomStringConvertible {

  public var description : String {
    var desc = "LoginParam("
    desc += "deviceId=\(String(describing: self.deviceId)), "
    desc += "udid=\(String(describing: self.udid)), "
    desc += "encPassword=\(String(describing: self.encPassword)), "
    desc += "osVersion=\(String(describing: self.osVersion)), "
    desc += "locale=\(String(describing: self.locale)), "
    desc += "hotpCounter=\(String(describing: self.hotpCounter)), "
    desc += "digest=\(String(describing: self.digest)), "
    desc += "risk=\(String(describing: self.risk)), "
    desc += "passwordLess=\(String(describing: self.passwordLess)), "
    desc += "cpuArch=\(String(describing: self.cpuArch)), "
    desc += "commClientType=\(String(describing: self.commClientType)), "
    desc += "sessionCookie=\(String(describing: self.sessionCookie))"
    return desc
  }

}

extension LoginParam : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (deviceId.hashValue)
    result = prime &* result &+ (udid.hashValue)
    result = prime &* result &+ (encPassword.hashValue)
    result = prime &* result &+ (osVersion.hashValue)
    result = prime &* result &+ (locale.hashValue)
    result = prime &* result &+ (hotpCounter.hashValue)
    result = prime &* result &+ (digest?.hashValue ?? 0)
    result = prime &* result &+ (risk?.hashValue ?? 0)
    result = prime &* result &+ (passwordLess.hashValue)
    result = prime &* result &+ (cpuArch.hashValue)
    result = prime &* result &+ (commClientType.hashValue)
    result = prime &* result &+ (sessionCookie?.hashValue ?? 0)
    return result
  }

}

extension LoginParam : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["deviceId": 1, "udid": 2, "encPassword": 3, "osVersion": 4, "locale": 5, "hotpCounter": 6, "digest": 7, "risk": 8, "passwordLess": 9, "cpuArch": 10, "commClientType": 11, "sessionCookie": 12, ]
  }

  public static var structName: String { return "LoginParam" }

  public static func read(from proto: TProtocol) throws -> LoginParam {
    _ = try proto.readStructBegin()
    var deviceId: Int32!
    var udid: Data!
    var encPassword: Data!
    var osVersion: String!
    var locale: String!
    var hotpCounter: Int32!
    var digest: Data?
    var risk: Data?
    var passwordLess: Bool!
    var cpuArch: CpuArch!
    var commClientType: CommClientType!
    var sessionCookie: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             deviceId = try Int32.read(from: proto)
        case (2, .string):           udid = try Data.read(from: proto)
        case (3, .string):           encPassword = try Data.read(from: proto)
        case (4, .string):           osVersion = try String.read(from: proto)
        case (5, .string):           locale = try String.read(from: proto)
        case (6, .i32):             hotpCounter = try Int32.read(from: proto)
        case (7, .string):           digest = try Data.read(from: proto)
        case (8, .string):           risk = try Data.read(from: proto)
        case (9, .bool):            passwordLess = try Bool.read(from: proto)
        case (10, .i32):             cpuArch = try CpuArch.read(from: proto)
        case (11, .i32):             commClientType = try CommClientType.read(from: proto)
        case (12, .string):           sessionCookie = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(deviceId, named: "deviceId")
    try proto.validateValue(udid, named: "udid")
    try proto.validateValue(encPassword, named: "encPassword")
    try proto.validateValue(osVersion, named: "osVersion")
    try proto.validateValue(locale, named: "locale")
    try proto.validateValue(hotpCounter, named: "hotpCounter")
    try proto.validateValue(passwordLess, named: "passwordLess")
    try proto.validateValue(cpuArch, named: "cpuArch")
    try proto.validateValue(commClientType, named: "commClientType")

    return LoginParam(deviceId: deviceId, udid: udid, encPassword: encPassword, osVersion: osVersion, locale: locale, hotpCounter: hotpCounter, digest: digest, risk: risk, passwordLess: passwordLess, cpuArch: cpuArch, commClientType: commClientType, sessionCookie: sessionCookie)
  }

}



public func ==(lhs: LoginResponse, rhs: LoginResponse) -> Bool {
  return
    (lhs.deviceKey == rhs.deviceKey) &&
    (lhs.oneTimePassword == rhs.oneTimePassword) &&
    (lhs.updateAvailableTill == rhs.updateAvailableTill) &&
    (lhs.passcodeValidFor == rhs.passcodeValidFor) &&
    (lhs.updateInfo == rhs.updateInfo) &&
    (lhs.licenceExpiresOn == rhs.licenceExpiresOn) &&
    (lhs.testLicence == rhs.testLicence) &&
    (lhs.ldapUser == rhs.ldapUser) &&
    (lhs.keepAliveSeconds == rhs.keepAliveSeconds) &&
    (lhs.sessionCookie == rhs.sessionCookie) &&
    (lhs.sessionCookieExpiresOn == rhs.sessionCookieExpiresOn)
}

extension LoginResponse : CustomStringConvertible {

  public var description : String {
    var desc = "LoginResponse("
    desc += "deviceKey=\(String(describing: self.deviceKey)), "
    desc += "oneTimePassword=\(String(describing: self.oneTimePassword)), "
    desc += "updateAvailableTill=\(String(describing: self.updateAvailableTill)), "
    desc += "passcodeValidFor=\(String(describing: self.passcodeValidFor)), "
    desc += "updateInfo=\(String(describing: self.updateInfo)), "
    desc += "licenceExpiresOn=\(String(describing: self.licenceExpiresOn)), "
    desc += "testLicence=\(String(describing: self.testLicence)), "
    desc += "ldapUser=\(String(describing: self.ldapUser)), "
    desc += "keepAliveSeconds=\(String(describing: self.keepAliveSeconds)), "
    desc += "sessionCookie=\(String(describing: self.sessionCookie)), "
    desc += "sessionCookieExpiresOn=\(String(describing: self.sessionCookieExpiresOn))"
    return desc
  }

}

extension LoginResponse : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (deviceKey.hashValue)
    result = prime &* result &+ (oneTimePassword.hashValue)
    result = prime &* result &+ (updateAvailableTill.hashValue)
    result = prime &* result &+ (passcodeValidFor.hashValue)
    result = prime &* result &+ (updateInfo?.hashValue ?? 0)
    result = prime &* result &+ (licenceExpiresOn.hashValue)
    result = prime &* result &+ (testLicence.hashValue)
    result = prime &* result &+ (ldapUser.hashValue)
    result = prime &* result &+ (keepAliveSeconds.hashValue)
    result = prime &* result &+ (sessionCookie?.hashValue ?? 0)
    result = prime &* result &+ (sessionCookieExpiresOn?.hashValue ?? 0)
    return result
  }

}

extension LoginResponse : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["deviceKey": 1, "oneTimePassword": 2, "updateAvailableTill": 3, "passcodeValidFor": 4, "updateInfo": 5, "licenceExpiresOn": 6, "testLicence": 7, "ldapUser": 8, "keepAliveSeconds": 9, "sessionCookie": 10, "sessionCookieExpiresOn": 11, ]
  }

  public static var structName: String { return "LoginResponse" }

  public static func read(from proto: TProtocol) throws -> LoginResponse {
    _ = try proto.readStructBegin()
    var deviceKey: Data!
    var oneTimePassword: String!
    var updateAvailableTill: Int64!
    var passcodeValidFor: Int32!
    var updateInfo: String?
    var licenceExpiresOn: Int64!
    var testLicence: Bool!
    var ldapUser: Bool!
    var keepAliveSeconds: Int32!
    var sessionCookie: String?
    var sessionCookieExpiresOn: Int32?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           deviceKey = try Data.read(from: proto)
        case (2, .string):           oneTimePassword = try String.read(from: proto)
        case (3, .i64):             updateAvailableTill = try Int64.read(from: proto)
        case (4, .i32):             passcodeValidFor = try Int32.read(from: proto)
        case (5, .string):           updateInfo = try String.read(from: proto)
        case (6, .i64):             licenceExpiresOn = try Int64.read(from: proto)
        case (7, .bool):            testLicence = try Bool.read(from: proto)
        case (8, .bool):            ldapUser = try Bool.read(from: proto)
        case (9, .i32):             keepAliveSeconds = try Int32.read(from: proto)
        case (10, .string):           sessionCookie = try String.read(from: proto)
        case (11, .i32):             sessionCookieExpiresOn = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(deviceKey, named: "deviceKey")
    try proto.validateValue(oneTimePassword, named: "oneTimePassword")
    try proto.validateValue(updateAvailableTill, named: "updateAvailableTill")
    try proto.validateValue(passcodeValidFor, named: "passcodeValidFor")
    try proto.validateValue(licenceExpiresOn, named: "licenceExpiresOn")
    try proto.validateValue(testLicence, named: "testLicence")
    try proto.validateValue(ldapUser, named: "ldapUser")
    try proto.validateValue(keepAliveSeconds, named: "keepAliveSeconds")

    return LoginResponse(deviceKey: deviceKey, oneTimePassword: oneTimePassword, updateAvailableTill: updateAvailableTill, passcodeValidFor: passcodeValidFor, updateInfo: updateInfo, licenceExpiresOn: licenceExpiresOn, testLicence: testLicence, ldapUser: ldapUser, keepAliveSeconds: keepAliveSeconds, sessionCookie: sessionCookie, sessionCookieExpiresOn: sessionCookieExpiresOn)
  }

}



public func ==(lhs: RequestActivationCodeResponse, rhs: RequestActivationCodeResponse) -> Bool {
  return
    (lhs.activationCode == rhs.activationCode) &&
    (lhs.validTill == rhs.validTill)
}

extension RequestActivationCodeResponse : CustomStringConvertible {

  public var description : String {
    var desc = "RequestActivationCodeResponse("
    desc += "activationCode=\(String(describing: self.activationCode)), "
    desc += "validTill=\(String(describing: self.validTill))"
    return desc
  }

}

extension RequestActivationCodeResponse : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (activationCode.hashValue)
    result = prime &* result &+ (validTill.hashValue)
    return result
  }

}

extension RequestActivationCodeResponse : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["activationCode": 1, "validTill": 2, ]
  }

  public static var structName: String { return "RequestActivationCodeResponse" }

  public static func read(from proto: TProtocol) throws -> RequestActivationCodeResponse {
    _ = try proto.readStructBegin()
    var activationCode: String!
    var validTill: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           activationCode = try String.read(from: proto)
        case (2, .i64):             validTill = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(activationCode, named: "activationCode")
    try proto.validateValue(validTill, named: "validTill")

    return RequestActivationCodeResponse(activationCode: activationCode, validTill: validTill)
  }

}



public func ==(lhs: AuthUserParam, rhs: AuthUserParam) -> Bool {
  return
    (lhs.authGatewayId == rhs.authGatewayId) &&
    (lhs.loginId == rhs.loginId) &&
    (lhs.authMethod == rhs.authMethod) &&
    (lhs.encPassword == rhs.encPassword) &&
    (lhs.encPasscode == rhs.encPasscode) &&
    (lhs.sharedSecret == rhs.sharedSecret) &&
    (lhs.udid == rhs.udid) &&
    (lhs.workstationName == rhs.workstationName) &&
    (lhs.clientType == rhs.clientType) &&
    (lhs.propertyMap == rhs.propertyMap)
}

extension AuthUserParam : CustomStringConvertible {

  public var description : String {
    var desc = "AuthUserParam("
    desc += "authGatewayId=\(String(describing: self.authGatewayId)), "
    desc += "loginId=\(String(describing: self.loginId)), "
    desc += "authMethod=\(String(describing: self.authMethod)), "
    desc += "encPassword=\(String(describing: self.encPassword)), "
    desc += "encPasscode=\(String(describing: self.encPasscode)), "
    desc += "sharedSecret=\(String(describing: self.sharedSecret)), "
    desc += "udid=\(String(describing: self.udid)), "
    desc += "workstationName=\(String(describing: self.workstationName)), "
    desc += "clientType=\(String(describing: self.clientType)), "
    desc += "propertyMap=\(String(describing: self.propertyMap))"
    return desc
  }

}

extension AuthUserParam : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (authGatewayId.hashValue)
    result = prime &* result &+ (loginId.hashValue)
    result = prime &* result &+ (authMethod.hashValue)
    result = prime &* result &+ (encPassword.hashValue)
    result = prime &* result &+ (encPasscode.hashValue)
    result = prime &* result &+ (sharedSecret.hashValue)
    result = prime &* result &+ (udid.hashValue)
    result = prime &* result &+ (workstationName.hashValue)
    result = prime &* result &+ (clientType.hashValue)
    result = prime &* result &+ (propertyMap.hashValue)
    return result
  }

}

extension AuthUserParam : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["authGatewayId": 1, "loginId": 2, "authMethod": 3, "encPassword": 4, "encPasscode": 5, "sharedSecret": 6, "udid": 7, "workstationName": 8, "clientType": 9, "propertyMap": 10, ]
  }

  public static var structName: String { return "AuthUserParam" }

  public static func read(from proto: TProtocol) throws -> AuthUserParam {
    _ = try proto.readStructBegin()
    var authGatewayId: String!
    var loginId: String!
    var authMethod: ThriftAuthMethod!
    var encPassword: Data!
    var encPasscode: Data!
    var sharedSecret: Data!
    var udid: Data!
    var workstationName: String!
    var clientType: ClientType!
    var propertyMap: TMap<String, String>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           authGatewayId = try String.read(from: proto)
        case (2, .string):           loginId = try String.read(from: proto)
        case (3, .i32):             authMethod = try ThriftAuthMethod.read(from: proto)
        case (4, .string):           encPassword = try Data.read(from: proto)
        case (5, .string):           encPasscode = try Data.read(from: proto)
        case (6, .string):           sharedSecret = try Data.read(from: proto)
        case (7, .string):           udid = try Data.read(from: proto)
        case (8, .string):           workstationName = try String.read(from: proto)
        case (9, .i32):             clientType = try ClientType.read(from: proto)
        case (10, .map):             propertyMap = try TMap<String, String>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(authGatewayId, named: "authGatewayId")
    try proto.validateValue(loginId, named: "loginId")
    try proto.validateValue(authMethod, named: "authMethod")
    try proto.validateValue(encPassword, named: "encPassword")
    try proto.validateValue(encPasscode, named: "encPasscode")
    try proto.validateValue(sharedSecret, named: "sharedSecret")
    try proto.validateValue(udid, named: "udid")
    try proto.validateValue(workstationName, named: "workstationName")
    try proto.validateValue(clientType, named: "clientType")
    try proto.validateValue(propertyMap, named: "propertyMap")

    return AuthUserParam(authGatewayId: authGatewayId, loginId: loginId, authMethod: authMethod, encPassword: encPassword, encPasscode: encPasscode, sharedSecret: sharedSecret, udid: udid, workstationName: workstationName, clientType: clientType, propertyMap: propertyMap)
  }

}



public func ==(lhs: AuthUserResponse, rhs: AuthUserResponse) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.authMethods == rhs.authMethods) &&
    (lhs.responseTime == rhs.responseTime) &&
    (lhs.msgId == rhs.msgId) &&
    (lhs.userKey == rhs.userKey) &&
    (lhs.sessionCookie == rhs.sessionCookie) &&
    (lhs.sessionCookieExpiresOn == rhs.sessionCookieExpiresOn) &&
    (lhs.secureMsgRandomCode == rhs.secureMsgRandomCode) &&
    (lhs.phoneNumber == rhs.phoneNumber) &&
    (lhs.fqUserLoginId == rhs.fqUserLoginId) &&
    (lhs.fidoResponse == rhs.fidoResponse) &&
    (lhs.ldapDomain == rhs.ldapDomain)
}

extension AuthUserResponse : CustomStringConvertible {

  public var description : String {
    var desc = "AuthUserResponse("
    desc += "success=\(String(describing: self.success)), "
    desc += "authMethods=\(String(describing: self.authMethods)), "
    desc += "responseTime=\(String(describing: self.responseTime)), "
    desc += "msgId=\(String(describing: self.msgId)), "
    desc += "userKey=\(String(describing: self.userKey)), "
    desc += "sessionCookie=\(String(describing: self.sessionCookie)), "
    desc += "sessionCookieExpiresOn=\(String(describing: self.sessionCookieExpiresOn)), "
    desc += "secureMsgRandomCode=\(String(describing: self.secureMsgRandomCode)), "
    desc += "phoneNumber=\(String(describing: self.phoneNumber)), "
    desc += "fqUserLoginId=\(String(describing: self.fqUserLoginId)), "
    desc += "fidoResponse=\(String(describing: self.fidoResponse)), "
    desc += "ldapDomain=\(String(describing: self.ldapDomain))"
    return desc
  }

}

extension AuthUserResponse : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success.hashValue)
    result = prime &* result &+ (authMethods?.hashValue ?? 0)
    result = prime &* result &+ (responseTime.hashValue)
    result = prime &* result &+ (msgId.hashValue)
    result = prime &* result &+ (userKey?.hashValue ?? 0)
    result = prime &* result &+ (sessionCookie?.hashValue ?? 0)
    result = prime &* result &+ (sessionCookieExpiresOn?.hashValue ?? 0)
    result = prime &* result &+ (secureMsgRandomCode?.hashValue ?? 0)
    result = prime &* result &+ (phoneNumber?.hashValue ?? 0)
    result = prime &* result &+ (fqUserLoginId?.hashValue ?? 0)
    result = prime &* result &+ (fidoResponse?.hashValue ?? 0)
    result = prime &* result &+ (ldapDomain?.hashValue ?? 0)
    return result
  }

}

extension AuthUserResponse : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["success": 1, "authMethods": 2, "responseTime": 3, "msgId": 4, "userKey": 5, "sessionCookie": 6, "sessionCookieExpiresOn": 7, "secureMsgRandomCode": 8, "phoneNumber": 9, "fqUserLoginId": 10, "fidoResponse": 11, "ldapDomain": 12, ]
  }

  public static var structName: String { return "AuthUserResponse" }

  public static func read(from proto: TProtocol) throws -> AuthUserResponse {
    _ = try proto.readStructBegin()
    var success: Bool!
    var authMethods: TList<ThriftAuthMethod>?
    var responseTime: Int32!
    var msgId: Int64!
    var userKey: Data?
    var sessionCookie: String?
    var sessionCookieExpiresOn: Int32?
    var secureMsgRandomCode: String?
    var phoneNumber: String?
    var fqUserLoginId: String?
    var fidoResponse: String?
    var ldapDomain: String?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .bool):            success = try Bool.read(from: proto)
        case (2, .list):            authMethods = try TList<ThriftAuthMethod>.read(from: proto)
        case (3, .i32):             responseTime = try Int32.read(from: proto)
        case (4, .i64):             msgId = try Int64.read(from: proto)
        case (5, .string):           userKey = try Data.read(from: proto)
        case (6, .string):           sessionCookie = try String.read(from: proto)
        case (7, .i32):             sessionCookieExpiresOn = try Int32.read(from: proto)
        case (8, .string):           secureMsgRandomCode = try String.read(from: proto)
        case (9, .string):           phoneNumber = try String.read(from: proto)
        case (10, .string):           fqUserLoginId = try String.read(from: proto)
        case (11, .string):           fidoResponse = try String.read(from: proto)
        case (12, .string):           ldapDomain = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(success, named: "success")
    try proto.validateValue(responseTime, named: "responseTime")
    try proto.validateValue(msgId, named: "msgId")

    return AuthUserResponse(success: success, authMethods: authMethods, responseTime: responseTime, msgId: msgId, userKey: userKey, sessionCookie: sessionCookie, sessionCookieExpiresOn: sessionCookieExpiresOn, secureMsgRandomCode: secureMsgRandomCode, phoneNumber: phoneNumber, fqUserLoginId: fqUserLoginId, fidoResponse: fidoResponse, ldapDomain: ldapDomain)
  }

}



public func ==(lhs: AuthConnectParam, rhs: AuthConnectParam) -> Bool {
  return
    (lhs.authGatewayId == rhs.authGatewayId) &&
    (lhs.sharedSecret == rhs.sharedSecret) &&
    (lhs.workstationName == rhs.workstationName) &&
    (lhs.udid == rhs.udid)
}

extension AuthConnectParam : CustomStringConvertible {

  public var description : String {
    var desc = "AuthConnectParam("
    desc += "authGatewayId=\(String(describing: self.authGatewayId)), "
    desc += "sharedSecret=\(String(describing: self.sharedSecret)), "
    desc += "workstationName=\(String(describing: self.workstationName)), "
    desc += "udid=\(String(describing: self.udid))"
    return desc
  }

}

extension AuthConnectParam : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (authGatewayId.hashValue)
    result = prime &* result &+ (sharedSecret.hashValue)
    result = prime &* result &+ (workstationName.hashValue)
    result = prime &* result &+ (udid.hashValue)
    return result
  }

}

extension AuthConnectParam : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["authGatewayId": 1, "sharedSecret": 2, "workstationName": 3, "udid": 4, ]
  }

  public static var structName: String { return "AuthConnectParam" }

  public static func read(from proto: TProtocol) throws -> AuthConnectParam {
    _ = try proto.readStructBegin()
    var authGatewayId: String!
    var sharedSecret: Data!
    var workstationName: String!
    var udid: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           authGatewayId = try String.read(from: proto)
        case (2, .string):           sharedSecret = try Data.read(from: proto)
        case (3, .string):           workstationName = try String.read(from: proto)
        case (4, .string):           udid = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(authGatewayId, named: "authGatewayId")
    try proto.validateValue(sharedSecret, named: "sharedSecret")
    try proto.validateValue(workstationName, named: "workstationName")
    try proto.validateValue(udid, named: "udid")

    return AuthConnectParam(authGatewayId: authGatewayId, sharedSecret: sharedSecret, workstationName: workstationName, udid: udid)
  }

}



public func ==(lhs: AuthSelectParam, rhs: AuthSelectParam) -> Bool {
  return
    (lhs.authGatewayId == rhs.authGatewayId) &&
    (lhs.loginId == rhs.loginId) &&
    (lhs.sharedSecret == rhs.sharedSecret) &&
    (lhs.udid == rhs.udid) &&
    (lhs.workstationName == rhs.workstationName) &&
    (lhs.clientType == rhs.clientType)
}

extension AuthSelectParam : CustomStringConvertible {

  public var description : String {
    var desc = "AuthSelectParam("
    desc += "authGatewayId=\(String(describing: self.authGatewayId)), "
    desc += "loginId=\(String(describing: self.loginId)), "
    desc += "sharedSecret=\(String(describing: self.sharedSecret)), "
    desc += "udid=\(String(describing: self.udid)), "
    desc += "workstationName=\(String(describing: self.workstationName)), "
    desc += "clientType=\(String(describing: self.clientType))"
    return desc
  }

}

extension AuthSelectParam : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (authGatewayId.hashValue)
    result = prime &* result &+ (loginId.hashValue)
    result = prime &* result &+ (sharedSecret.hashValue)
    result = prime &* result &+ (udid.hashValue)
    result = prime &* result &+ (workstationName.hashValue)
    result = prime &* result &+ (clientType.hashValue)
    return result
  }

}

extension AuthSelectParam : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["authGatewayId": 1, "loginId": 2, "sharedSecret": 3, "udid": 4, "workstationName": 5, "clientType": 6, ]
  }

  public static var structName: String { return "AuthSelectParam" }

  public static func read(from proto: TProtocol) throws -> AuthSelectParam {
    _ = try proto.readStructBegin()
    var authGatewayId: String!
    var loginId: String!
    var sharedSecret: Data!
    var udid: Data!
    var workstationName: String!
    var clientType: ClientType!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           authGatewayId = try String.read(from: proto)
        case (2, .string):           loginId = try String.read(from: proto)
        case (3, .string):           sharedSecret = try Data.read(from: proto)
        case (4, .string):           udid = try Data.read(from: proto)
        case (5, .string):           workstationName = try String.read(from: proto)
        case (6, .i32):             clientType = try ClientType.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(authGatewayId, named: "authGatewayId")
    try proto.validateValue(loginId, named: "loginId")
    try proto.validateValue(sharedSecret, named: "sharedSecret")
    try proto.validateValue(udid, named: "udid")
    try proto.validateValue(workstationName, named: "workstationName")
    try proto.validateValue(clientType, named: "clientType")

    return AuthSelectParam(authGatewayId: authGatewayId, loginId: loginId, sharedSecret: sharedSecret, udid: udid, workstationName: workstationName, clientType: clientType)
  }

}



public func ==(lhs: AuthSelectResponse, rhs: AuthSelectResponse) -> Bool {
  return
    (lhs.authMethods == rhs.authMethods)
}

extension AuthSelectResponse : CustomStringConvertible {

  public var description : String {
    var desc = "AuthSelectResponse("
    desc += "authMethods=\(String(describing: self.authMethods))"
    return desc
  }

}

extension AuthSelectResponse : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (authMethods.hashValue)
    return result
  }

}

extension AuthSelectResponse : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["authMethods": 1, ]
  }

  public static var structName: String { return "AuthSelectResponse" }

  public static func read(from proto: TProtocol) throws -> AuthSelectResponse {
    _ = try proto.readStructBegin()
    var authMethods: TList<ThriftAuthMethod>!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .list):            authMethods = try TList<ThriftAuthMethod>.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(authMethods, named: "authMethods")

    return AuthSelectResponse(authMethods: authMethods)
  }

}



public func ==(lhs: QrCodeResponse, rhs: QrCodeResponse) -> Bool {
  return
    (lhs.timeToLive == rhs.timeToLive) &&
    (lhs.data == rhs.data)
}

extension QrCodeResponse : CustomStringConvertible {

  public var description : String {
    var desc = "QrCodeResponse("
    desc += "timeToLive=\(String(describing: self.timeToLive)), "
    desc += "data=\(String(describing: self.data))"
    return desc
  }

}

extension QrCodeResponse : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (timeToLive.hashValue)
    result = prime &* result &+ (data.hashValue)
    return result
  }

}

extension QrCodeResponse : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["timeToLive": 1, "data": 2, ]
  }

  public static var structName: String { return "QrCodeResponse" }

  public static func read(from proto: TProtocol) throws -> QrCodeResponse {
    _ = try proto.readStructBegin()
    var timeToLive: Int32!
    var data: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             timeToLive = try Int32.read(from: proto)
        case (2, .string):           data = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(timeToLive, named: "timeToLive")
    try proto.validateValue(data, named: "data")

    return QrCodeResponse(timeToLive: timeToLive, data: data)
  }

}



public func ==(lhs: SignatureParam, rhs: SignatureParam) -> Bool {
  return
    (lhs.clientSignature == rhs.clientSignature) &&
    (lhs.appDigest == rhs.appDigest)
}

extension SignatureParam : CustomStringConvertible {

  public var description : String {
    var desc = "SignatureParam("
    desc += "clientSignature=\(String(describing: self.clientSignature)), "
    desc += "appDigest=\(String(describing: self.appDigest))"
    return desc
  }

}

extension SignatureParam : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (clientSignature.hashValue)
    result = prime &* result &+ (appDigest.hashValue)
    return result
  }

}

extension SignatureParam : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["clientSignature": 1, "appDigest": 2, ]
  }

  public static var structName: String { return "SignatureParam" }

  public static func read(from proto: TProtocol) throws -> SignatureParam {
    _ = try proto.readStructBegin()
    var clientSignature: Data!
    var appDigest: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           clientSignature = try Data.read(from: proto)
        case (2, .string):           appDigest = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(clientSignature, named: "clientSignature")
    try proto.validateValue(appDigest, named: "appDigest")

    return SignatureParam(clientSignature: clientSignature, appDigest: appDigest)
  }

}



public func ==(lhs: SignatureResponse, rhs: SignatureResponse) -> Bool {
  return
    (lhs.reconnectTicket == rhs.reconnectTicket) &&
    (lhs.keepAliveSeconds == rhs.keepAliveSeconds)
}

extension SignatureResponse : CustomStringConvertible {

  public var description : String {
    var desc = "SignatureResponse("
    desc += "reconnectTicket=\(String(describing: self.reconnectTicket)), "
    desc += "keepAliveSeconds=\(String(describing: self.keepAliveSeconds))"
    return desc
  }

}

extension SignatureResponse : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (reconnectTicket.hashValue)
    result = prime &* result &+ (keepAliveSeconds.hashValue)
    return result
  }

}

extension SignatureResponse : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["reconnectTicket": 1, "keepAliveSeconds": 2, ]
  }

  public static var structName: String { return "SignatureResponse" }

  public static func read(from proto: TProtocol) throws -> SignatureResponse {
    _ = try proto.readStructBegin()
    var reconnectTicket: Data!
    var keepAliveSeconds: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           reconnectTicket = try Data.read(from: proto)
        case (2, .i32):             keepAliveSeconds = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(reconnectTicket, named: "reconnectTicket")
    try proto.validateValue(keepAliveSeconds, named: "keepAliveSeconds")

    return SignatureResponse(reconnectTicket: reconnectTicket, keepAliveSeconds: keepAliveSeconds)
  }

}



public func ==(lhs: DeviceOfflineKey, rhs: DeviceOfflineKey) -> Bool {
  return
    (lhs.udid == rhs.udid) &&
    (lhs.offlineKey == rhs.offlineKey) &&
    (lhs.window == rhs.window) &&
    (lhs.validFor == rhs.validFor) &&
    (lhs.algorithm == rhs.algorithm)
}

extension DeviceOfflineKey : CustomStringConvertible {

  public var description : String {
    var desc = "DeviceOfflineKey("
    desc += "udid=\(String(describing: self.udid)), "
    desc += "offlineKey=\(String(describing: self.offlineKey)), "
    desc += "window=\(String(describing: self.window)), "
    desc += "validFor=\(String(describing: self.validFor)), "
    desc += "algorithm=\(String(describing: self.algorithm))"
    return desc
  }

}

extension DeviceOfflineKey : Hashable {

  public var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (udid?.hashValue ?? 0)
    result = prime &* result &+ (offlineKey.hashValue)
    result = prime &* result &+ (window.hashValue)
    result = prime &* result &+ (validFor.hashValue)
    result = prime &* result &+ (algorithm.hashValue)
    return result
  }

}

extension DeviceOfflineKey : TStruct {

  public static var fieldIds: [String: Int32] {
    return ["udid": 1, "offlineKey": 2, "window": 3, "validFor": 4, "algorithm": 5, ]
  }

  public static var structName: String { return "DeviceOfflineKey" }

  public static func read(from proto: TProtocol) throws -> DeviceOfflineKey {
    _ = try proto.readStructBegin()
    var udid: Data?
    var offlineKey: Data!
    var window: Int32!
    var validFor: Int32!
    var algorithm: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           udid = try Data.read(from: proto)
        case (2, .string):           offlineKey = try Data.read(from: proto)
        case (3, .i32):             window = try Int32.read(from: proto)
        case (4, .i32):             validFor = try Int32.read(from: proto)
        case (5, .string):           algorithm = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(offlineKey, named: "offlineKey")
    try proto.validateValue(window, named: "window")
    try proto.validateValue(validFor, named: "validFor")
    try proto.validateValue(algorithm, named: "algorithm")

    return DeviceOfflineKey(udid: udid, offlineKey: offlineKey, window: window, validFor: validFor, algorithm: algorithm)
  }

}



fileprivate final class AppToServer_serverSignature_args {

  fileprivate var serverSignatureParam: ServerSignatureParam


  fileprivate init(serverSignatureParam: ServerSignatureParam) {
    self.serverSignatureParam = serverSignatureParam
  }

}

fileprivate func ==(lhs: AppToServer_serverSignature_args, rhs: AppToServer_serverSignature_args) -> Bool {
  return
    (lhs.serverSignatureParam == rhs.serverSignatureParam)
}

extension AppToServer_serverSignature_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (serverSignatureParam.hashValue)
    return result
  }

}

extension AppToServer_serverSignature_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["serverSignatureParam": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_serverSignature_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_serverSignature_args {
    _ = try proto.readStructBegin()
    var serverSignatureParam: ServerSignatureParam!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           serverSignatureParam = try ServerSignatureParam.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(serverSignatureParam, named: "serverSignatureParam")

    return AppToServer_serverSignature_args(serverSignatureParam: serverSignatureParam)
  }

}



fileprivate final class AppToServer_serverSignature_result {

  fileprivate var success: ServerSignatureResponse?

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(success: ServerSignatureResponse?, ouch: AppException?) {
    self.success = success
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_serverSignature_result, rhs: AppToServer_serverSignature_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_serverSignature_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_serverSignature_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_serverSignature_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_serverSignature_result {
    _ = try proto.readStructBegin()
    var success: ServerSignatureResponse?
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ServerSignatureResponse.read(from: proto)
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_serverSignature_result(success: success, ouch: ouch)
  }

}



fileprivate final class AppToServer_getDomainSdkConfig_args {

  fileprivate var domainSdkConfigParam: DomainSdkConfigParam


  fileprivate init(domainSdkConfigParam: DomainSdkConfigParam) {
    self.domainSdkConfigParam = domainSdkConfigParam
  }

}

fileprivate func ==(lhs: AppToServer_getDomainSdkConfig_args, rhs: AppToServer_getDomainSdkConfig_args) -> Bool {
  return
    (lhs.domainSdkConfigParam == rhs.domainSdkConfigParam)
}

extension AppToServer_getDomainSdkConfig_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (domainSdkConfigParam.hashValue)
    return result
  }

}

extension AppToServer_getDomainSdkConfig_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["domainSdkConfigParam": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_getDomainSdkConfig_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_getDomainSdkConfig_args {
    _ = try proto.readStructBegin()
    var domainSdkConfigParam: DomainSdkConfigParam!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           domainSdkConfigParam = try DomainSdkConfigParam.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(domainSdkConfigParam, named: "domainSdkConfigParam")

    return AppToServer_getDomainSdkConfig_args(domainSdkConfigParam: domainSdkConfigParam)
  }

}



fileprivate final class AppToServer_getDomainSdkConfig_result {

  fileprivate var success: DomainSdkConfigResponse?

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(success: DomainSdkConfigResponse?, ouch: AppException?) {
    self.success = success
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_getDomainSdkConfig_result, rhs: AppToServer_getDomainSdkConfig_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_getDomainSdkConfig_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_getDomainSdkConfig_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_getDomainSdkConfig_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_getDomainSdkConfig_result {
    _ = try proto.readStructBegin()
    var success: DomainSdkConfigResponse?
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try DomainSdkConfigResponse.read(from: proto)
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_getDomainSdkConfig_result(success: success, ouch: ouch)
  }

}



fileprivate final class AppToServer_registerDispatcher_args {

  fileprivate var registerDispatcherParam: RegisterDispatcherParam


  fileprivate init(registerDispatcherParam: RegisterDispatcherParam) {
    self.registerDispatcherParam = registerDispatcherParam
  }

}

fileprivate func ==(lhs: AppToServer_registerDispatcher_args, rhs: AppToServer_registerDispatcher_args) -> Bool {
  return
    (lhs.registerDispatcherParam == rhs.registerDispatcherParam)
}

extension AppToServer_registerDispatcher_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (registerDispatcherParam.hashValue)
    return result
  }

}

extension AppToServer_registerDispatcher_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["registerDispatcherParam": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_registerDispatcher_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_registerDispatcher_args {
    _ = try proto.readStructBegin()
    var registerDispatcherParam: RegisterDispatcherParam!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           registerDispatcherParam = try RegisterDispatcherParam.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(registerDispatcherParam, named: "registerDispatcherParam")

    return AppToServer_registerDispatcher_args(registerDispatcherParam: registerDispatcherParam)
  }

}



fileprivate final class AppToServer_registerDispatcher_result {

  fileprivate var success: RegisterDispatcherResponse?

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(success: RegisterDispatcherResponse?, ouch: AppException?) {
    self.success = success
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_registerDispatcher_result, rhs: AppToServer_registerDispatcher_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_registerDispatcher_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_registerDispatcher_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_registerDispatcher_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_registerDispatcher_result {
    _ = try proto.readStructBegin()
    var success: RegisterDispatcherResponse?
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try RegisterDispatcherResponse.read(from: proto)
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_registerDispatcher_result(success: success, ouch: ouch)
  }

}



fileprivate final class AppToServer_activation_args {

  fileprivate var activationParam: ActivationParam


  fileprivate init(activationParam: ActivationParam) {
    self.activationParam = activationParam
  }

}

fileprivate func ==(lhs: AppToServer_activation_args, rhs: AppToServer_activation_args) -> Bool {
  return
    (lhs.activationParam == rhs.activationParam)
}

extension AppToServer_activation_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (activationParam.hashValue)
    return result
  }

}

extension AppToServer_activation_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["activationParam": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_activation_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_activation_args {
    _ = try proto.readStructBegin()
    var activationParam: ActivationParam!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           activationParam = try ActivationParam.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(activationParam, named: "activationParam")

    return AppToServer_activation_args(activationParam: activationParam)
  }

}



fileprivate final class AppToServer_activation_result {

  fileprivate var success: ActivationResponse?

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(success: ActivationResponse?, ouch: AppException?) {
    self.success = success
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_activation_result, rhs: AppToServer_activation_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_activation_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_activation_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_activation_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_activation_result {
    _ = try proto.readStructBegin()
    var success: ActivationResponse?
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try ActivationResponse.read(from: proto)
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_activation_result(success: success, ouch: ouch)
  }

}



fileprivate final class AppToServer_login_args {

  fileprivate var loginParam: LoginParam


  fileprivate init(loginParam: LoginParam) {
    self.loginParam = loginParam
  }

}

fileprivate func ==(lhs: AppToServer_login_args, rhs: AppToServer_login_args) -> Bool {
  return
    (lhs.loginParam == rhs.loginParam)
}

extension AppToServer_login_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (loginParam.hashValue)
    return result
  }

}

extension AppToServer_login_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["loginParam": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_login_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_login_args {
    _ = try proto.readStructBegin()
    var loginParam: LoginParam!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           loginParam = try LoginParam.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(loginParam, named: "loginParam")

    return AppToServer_login_args(loginParam: loginParam)
  }

}



fileprivate final class AppToServer_login_result {

  fileprivate var success: LoginResponse?

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(success: LoginResponse?, ouch: AppException?) {
    self.success = success
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_login_result, rhs: AppToServer_login_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_login_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_login_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_login_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_login_result {
    _ = try proto.readStructBegin()
    var success: LoginResponse?
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try LoginResponse.read(from: proto)
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_login_result(success: success, ouch: ouch)
  }

}



fileprivate final class AppToServer_clientSignature_args {

  fileprivate var signaturenParam: SignatureParam


  fileprivate init(signaturenParam: SignatureParam) {
    self.signaturenParam = signaturenParam
  }

}

fileprivate func ==(lhs: AppToServer_clientSignature_args, rhs: AppToServer_clientSignature_args) -> Bool {
  return
    (lhs.signaturenParam == rhs.signaturenParam)
}

extension AppToServer_clientSignature_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (signaturenParam.hashValue)
    return result
  }

}

extension AppToServer_clientSignature_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["signaturenParam": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_clientSignature_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_clientSignature_args {
    _ = try proto.readStructBegin()
    var signaturenParam: SignatureParam!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           signaturenParam = try SignatureParam.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(signaturenParam, named: "signaturenParam")

    return AppToServer_clientSignature_args(signaturenParam: signaturenParam)
  }

}



fileprivate final class AppToServer_clientSignature_result {

  fileprivate var success: SignatureResponse?

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(success: SignatureResponse?, ouch: AppException?) {
    self.success = success
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_clientSignature_result, rhs: AppToServer_clientSignature_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_clientSignature_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_clientSignature_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_clientSignature_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_clientSignature_result {
    _ = try proto.readStructBegin()
    var success: SignatureResponse?
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try SignatureResponse.read(from: proto)
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_clientSignature_result(success: success, ouch: ouch)
  }

}



fileprivate final class AppToServer_getTemplateFromId_args {

  fileprivate var id: Int32


  fileprivate init(id: Int32) {
    self.id = id
  }

}

fileprivate func ==(lhs: AppToServer_getTemplateFromId_args, rhs: AppToServer_getTemplateFromId_args) -> Bool {
  return
    (lhs.id == rhs.id)
}

extension AppToServer_getTemplateFromId_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (id.hashValue)
    return result
  }

}

extension AppToServer_getTemplateFromId_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["id": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_getTemplateFromId_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_getTemplateFromId_args {
    _ = try proto.readStructBegin()
    var id: Int32!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             id = try Int32.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(id, named: "id")

    return AppToServer_getTemplateFromId_args(id: id)
  }

}



fileprivate final class AppToServer_getTemplateFromId_result {

  fileprivate var success: Template?

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(success: Template?, ouch: AppException?) {
    self.success = success
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_getTemplateFromId_result, rhs: AppToServer_getTemplateFromId_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_getTemplateFromId_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_getTemplateFromId_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_getTemplateFromId_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_getTemplateFromId_result {
    _ = try proto.readStructBegin()
    var success: Template?
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try Template.read(from: proto)
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_getTemplateFromId_result(success: success, ouch: ouch)
  }

}



fileprivate final class AppToServer_sendMessage_args {

  fileprivate var appMessage: AppMessage


  fileprivate init(appMessage: AppMessage) {
    self.appMessage = appMessage
  }

}

fileprivate func ==(lhs: AppToServer_sendMessage_args, rhs: AppToServer_sendMessage_args) -> Bool {
  return
    (lhs.appMessage == rhs.appMessage)
}

extension AppToServer_sendMessage_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (appMessage.hashValue)
    return result
  }

}

extension AppToServer_sendMessage_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["appMessage": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_sendMessage_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_sendMessage_args {
    _ = try proto.readStructBegin()
    var appMessage: AppMessage!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           appMessage = try AppMessage.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(appMessage, named: "appMessage")

    return AppToServer_sendMessage_args(appMessage: appMessage)
  }

}



fileprivate final class AppToServer_sendMessage_result {

  fileprivate var success: Bool?

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(success: Bool?, ouch: AppException?) {
    self.success = success
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_sendMessage_result, rhs: AppToServer_sendMessage_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_sendMessage_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_sendMessage_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_sendMessage_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_sendMessage_result {
    _ = try proto.readStructBegin()
    var success: Bool?
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .bool):            success = try Bool.read(from: proto)
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_sendMessage_result(success: success, ouch: ouch)
  }

}



fileprivate final class AppToServer_sendMessageResponse_args {

  fileprivate var appMessageResponse: AppMessageResponse


  fileprivate init(appMessageResponse: AppMessageResponse) {
    self.appMessageResponse = appMessageResponse
  }

}

fileprivate func ==(lhs: AppToServer_sendMessageResponse_args, rhs: AppToServer_sendMessageResponse_args) -> Bool {
  return
    (lhs.appMessageResponse == rhs.appMessageResponse)
}

extension AppToServer_sendMessageResponse_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (appMessageResponse.hashValue)
    return result
  }

}

extension AppToServer_sendMessageResponse_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["appMessageResponse": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_sendMessageResponse_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_sendMessageResponse_args {
    _ = try proto.readStructBegin()
    var appMessageResponse: AppMessageResponse!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           appMessageResponse = try AppMessageResponse.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(appMessageResponse, named: "appMessageResponse")

    return AppToServer_sendMessageResponse_args(appMessageResponse: appMessageResponse)
  }

}



fileprivate final class AppToServer_sendMessageResponse_result {

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(ouch: AppException?) {
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_sendMessageResponse_result, rhs: AppToServer_sendMessageResponse_result) -> Bool {
  return
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_sendMessageResponse_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_sendMessageResponse_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_sendMessageResponse_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_sendMessageResponse_result {
    _ = try proto.readStructBegin()
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_sendMessageResponse_result(ouch: ouch)
  }

}



fileprivate final class AppToServer_sendLoginQrCode_args {

  fileprivate var data: String


  fileprivate init(data: String) {
    self.data = data
  }

}

fileprivate func ==(lhs: AppToServer_sendLoginQrCode_args, rhs: AppToServer_sendLoginQrCode_args) -> Bool {
  return
    (lhs.data == rhs.data)
}

extension AppToServer_sendLoginQrCode_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (data.hashValue)
    return result
  }

}

extension AppToServer_sendLoginQrCode_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["data": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_sendLoginQrCode_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_sendLoginQrCode_args {
    _ = try proto.readStructBegin()
    var data: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           data = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(data, named: "data")

    return AppToServer_sendLoginQrCode_args(data: data)
  }

}



fileprivate final class AppToServer_sendLoginQrCode_result {

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(ouch: AppException?) {
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_sendLoginQrCode_result, rhs: AppToServer_sendLoginQrCode_result) -> Bool {
  return
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_sendLoginQrCode_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_sendLoginQrCode_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_sendLoginQrCode_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_sendLoginQrCode_result {
    _ = try proto.readStructBegin()
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_sendLoginQrCode_result(ouch: ouch)
  }

}



fileprivate final class AppToServer_getLoginQrCode_args {

  fileprivate var operatorId: String

  fileprivate var sessionId: String


  fileprivate init(operatorId: String, sessionId: String) {
    self.operatorId = operatorId
    self.sessionId = sessionId
  }

}

fileprivate func ==(lhs: AppToServer_getLoginQrCode_args, rhs: AppToServer_getLoginQrCode_args) -> Bool {
  return
    (lhs.operatorId == rhs.operatorId) &&
    (lhs.sessionId == rhs.sessionId)
}

extension AppToServer_getLoginQrCode_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (operatorId.hashValue)
    result = prime &* result &+ (sessionId.hashValue)
    return result
  }

}

extension AppToServer_getLoginQrCode_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["operatorId": 1, "sessionId": 2, ]
  }

  fileprivate static var structName: String { return "AppToServer_getLoginQrCode_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_getLoginQrCode_args {
    _ = try proto.readStructBegin()
    var operatorId: String!
    var sessionId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           operatorId = try String.read(from: proto)
        case (2, .string):           sessionId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(operatorId, named: "operatorId")
    try proto.validateValue(sessionId, named: "sessionId")

    return AppToServer_getLoginQrCode_args(operatorId: operatorId, sessionId: sessionId)
  }

}



fileprivate final class AppToServer_getLoginQrCode_result {

  fileprivate var success: QrCodeResponse?

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(success: QrCodeResponse?, ouch: AppException?) {
    self.success = success
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_getLoginQrCode_result, rhs: AppToServer_getLoginQrCode_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_getLoginQrCode_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_getLoginQrCode_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_getLoginQrCode_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_getLoginQrCode_result {
    _ = try proto.readStructBegin()
    var success: QrCodeResponse?
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try QrCodeResponse.read(from: proto)
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_getLoginQrCode_result(success: success, ouch: ouch)
  }

}



fileprivate final class AppToServer_changePassword_args {

  fileprivate var encPassword: Data

  fileprivate var newEncPassword: Data


  fileprivate init(encPassword: Data, newEncPassword: Data) {
    self.encPassword = encPassword
    self.newEncPassword = newEncPassword
  }

}

fileprivate func ==(lhs: AppToServer_changePassword_args, rhs: AppToServer_changePassword_args) -> Bool {
  return
    (lhs.encPassword == rhs.encPassword) &&
    (lhs.newEncPassword == rhs.newEncPassword)
}

extension AppToServer_changePassword_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (encPassword.hashValue)
    result = prime &* result &+ (newEncPassword.hashValue)
    return result
  }

}

extension AppToServer_changePassword_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["encPassword": 1, "newEncPassword": 2, ]
  }

  fileprivate static var structName: String { return "AppToServer_changePassword_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_changePassword_args {
    _ = try proto.readStructBegin()
    var encPassword: Data!
    var newEncPassword: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           encPassword = try Data.read(from: proto)
        case (2, .string):           newEncPassword = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(encPassword, named: "encPassword")
    try proto.validateValue(newEncPassword, named: "newEncPassword")

    return AppToServer_changePassword_args(encPassword: encPassword, newEncPassword: newEncPassword)
  }

}



fileprivate final class AppToServer_changePassword_result {

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(ouch: AppException?) {
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_changePassword_result, rhs: AppToServer_changePassword_result) -> Bool {
  return
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_changePassword_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_changePassword_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_changePassword_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_changePassword_result {
    _ = try proto.readStructBegin()
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_changePassword_result(ouch: ouch)
  }

}



fileprivate final class AppToServer_getCloudSafe_args {

  fileprivate var uniqueKey: SdkCloudSafeKey

  fileprivate var userLoginId: String


  fileprivate init(uniqueKey: SdkCloudSafeKey, userLoginId: String) {
    self.uniqueKey = uniqueKey
    self.userLoginId = userLoginId
  }

}

fileprivate func ==(lhs: AppToServer_getCloudSafe_args, rhs: AppToServer_getCloudSafe_args) -> Bool {
  return
    (lhs.uniqueKey == rhs.uniqueKey) &&
    (lhs.userLoginId == rhs.userLoginId)
}

extension AppToServer_getCloudSafe_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (uniqueKey.hashValue)
    result = prime &* result &+ (userLoginId.hashValue)
    return result
  }

}

extension AppToServer_getCloudSafe_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["uniqueKey": 1, "userLoginId": 2, ]
  }

  fileprivate static var structName: String { return "AppToServer_getCloudSafe_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_getCloudSafe_args {
    _ = try proto.readStructBegin()
    var uniqueKey: SdkCloudSafeKey!
    var userLoginId: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           uniqueKey = try SdkCloudSafeKey.read(from: proto)
        case (2, .string):           userLoginId = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(uniqueKey, named: "uniqueKey")
    try proto.validateValue(userLoginId, named: "userLoginId")

    return AppToServer_getCloudSafe_args(uniqueKey: uniqueKey, userLoginId: userLoginId)
  }

}



fileprivate final class AppToServer_getCloudSafe_result {

  fileprivate var success: SdkCloudSafe?

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(success: SdkCloudSafe?, ouch: AppException?) {
    self.success = success
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_getCloudSafe_result, rhs: AppToServer_getCloudSafe_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_getCloudSafe_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_getCloudSafe_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_getCloudSafe_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_getCloudSafe_result {
    _ = try proto.readStructBegin()
    var success: SdkCloudSafe?
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try SdkCloudSafe.read(from: proto)
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_getCloudSafe_result(success: success, ouch: ouch)
  }

}



fileprivate final class AppToServer_setCloudSafe_args {

  fileprivate var sdkCloudSafe: SdkCloudSafe


  fileprivate init(sdkCloudSafe: SdkCloudSafe) {
    self.sdkCloudSafe = sdkCloudSafe
  }

}

fileprivate func ==(lhs: AppToServer_setCloudSafe_args, rhs: AppToServer_setCloudSafe_args) -> Bool {
  return
    (lhs.sdkCloudSafe == rhs.sdkCloudSafe)
}

extension AppToServer_setCloudSafe_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (sdkCloudSafe.hashValue)
    return result
  }

}

extension AppToServer_setCloudSafe_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["sdkCloudSafe": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_setCloudSafe_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_setCloudSafe_args {
    _ = try proto.readStructBegin()
    var sdkCloudSafe: SdkCloudSafe!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           sdkCloudSafe = try SdkCloudSafe.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(sdkCloudSafe, named: "sdkCloudSafe")

    return AppToServer_setCloudSafe_args(sdkCloudSafe: sdkCloudSafe)
  }

}



fileprivate final class AppToServer_setCloudSafe_result {

  fileprivate var success: Int64?

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(success: Int64?, ouch: AppException?) {
    self.success = success
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_setCloudSafe_result, rhs: AppToServer_setCloudSafe_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_setCloudSafe_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_setCloudSafe_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_setCloudSafe_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_setCloudSafe_result {
    _ = try proto.readStructBegin()
    var success: Int64?
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i64):             success = try Int64.read(from: proto)
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_setCloudSafe_result(success: success, ouch: ouch)
  }

}



fileprivate final class AppToServer_getCloudSafeList_args {

  fileprivate var nameFilter: String

  fileprivate var includeShare: Bool

  fileprivate var modifiedFromEpoch: Int64

  fileprivate var owner: CloudSafeOwner


  fileprivate init(nameFilter: String, includeShare: Bool, modifiedFromEpoch: Int64, owner: CloudSafeOwner) {
    self.nameFilter = nameFilter
    self.includeShare = includeShare
    self.modifiedFromEpoch = modifiedFromEpoch
    self.owner = owner
  }

}

fileprivate func ==(lhs: AppToServer_getCloudSafeList_args, rhs: AppToServer_getCloudSafeList_args) -> Bool {
  return
    (lhs.nameFilter == rhs.nameFilter) &&
    (lhs.includeShare == rhs.includeShare) &&
    (lhs.modifiedFromEpoch == rhs.modifiedFromEpoch) &&
    (lhs.owner == rhs.owner)
}

extension AppToServer_getCloudSafeList_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (nameFilter.hashValue)
    result = prime &* result &+ (includeShare.hashValue)
    result = prime &* result &+ (modifiedFromEpoch.hashValue)
    result = prime &* result &+ (owner.hashValue)
    return result
  }

}

extension AppToServer_getCloudSafeList_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["nameFilter": 1, "includeShare": 2, "modifiedFromEpoch": 3, "owner": 4, ]
  }

  fileprivate static var structName: String { return "AppToServer_getCloudSafeList_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_getCloudSafeList_args {
    _ = try proto.readStructBegin()
    var nameFilter: String!
    var includeShare: Bool!
    var modifiedFromEpoch: Int64!
    var owner: CloudSafeOwner!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           nameFilter = try String.read(from: proto)
        case (2, .bool):            includeShare = try Bool.read(from: proto)
        case (3, .i64):             modifiedFromEpoch = try Int64.read(from: proto)
        case (4, .i32):             owner = try CloudSafeOwner.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(nameFilter, named: "nameFilter")
    try proto.validateValue(includeShare, named: "includeShare")
    try proto.validateValue(modifiedFromEpoch, named: "modifiedFromEpoch")
    try proto.validateValue(owner, named: "owner")

    return AppToServer_getCloudSafeList_args(nameFilter: nameFilter, includeShare: includeShare, modifiedFromEpoch: modifiedFromEpoch, owner: owner)
  }

}



fileprivate final class AppToServer_getCloudSafeList_result {

  fileprivate var success: TList<SdkCloudSafe>?

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(success: TList<SdkCloudSafe>?, ouch: AppException?) {
    self.success = success
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_getCloudSafeList_result, rhs: AppToServer_getCloudSafeList_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_getCloudSafeList_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_getCloudSafeList_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_getCloudSafeList_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_getCloudSafeList_result {
    _ = try proto.readStructBegin()
    var success: TList<SdkCloudSafe>?
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<SdkCloudSafe>.read(from: proto)
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_getCloudSafeList_result(success: success, ouch: ouch)
  }

}



fileprivate final class AppToServer_disconnect_args {

  fileprivate var appErrorCodes: AppErrorCodes

  fileprivate var message: String


  fileprivate init(appErrorCodes: AppErrorCodes, message: String) {
    self.appErrorCodes = appErrorCodes
    self.message = message
  }

}

fileprivate func ==(lhs: AppToServer_disconnect_args, rhs: AppToServer_disconnect_args) -> Bool {
  return
    (lhs.appErrorCodes == rhs.appErrorCodes) &&
    (lhs.message == rhs.message)
}

extension AppToServer_disconnect_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (appErrorCodes.hashValue)
    result = prime &* result &+ (message.hashValue)
    return result
  }

}

extension AppToServer_disconnect_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["appErrorCodes": 1, "message": 2, ]
  }

  fileprivate static var structName: String { return "AppToServer_disconnect_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_disconnect_args {
    _ = try proto.readStructBegin()
    var appErrorCodes: AppErrorCodes!
    var message: String!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i32):             appErrorCodes = try AppErrorCodes.read(from: proto)
        case (2, .string):           message = try String.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(appErrorCodes, named: "appErrorCodes")
    try proto.validateValue(message, named: "message")

    return AppToServer_disconnect_args(appErrorCodes: appErrorCodes, message: message)
  }

}



fileprivate final class AppToServer_disconnect_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: AppToServer_disconnect_result, rhs: AppToServer_disconnect_result) -> Bool {
  return true
}

extension AppToServer_disconnect_result : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension AppToServer_disconnect_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "AppToServer_disconnect_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_disconnect_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_disconnect_result()
  }

}



fileprivate final class AppToServer_keepAlive_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: AppToServer_keepAlive_args, rhs: AppToServer_keepAlive_args) -> Bool {
  return true
}

extension AppToServer_keepAlive_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension AppToServer_keepAlive_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "AppToServer_keepAlive_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_keepAlive_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_keepAlive_args()
  }

}



fileprivate final class AppToServer_keepAlive_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: AppToServer_keepAlive_result, rhs: AppToServer_keepAlive_result) -> Bool {
  return true
}

extension AppToServer_keepAlive_result : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension AppToServer_keepAlive_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "AppToServer_keepAlive_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_keepAlive_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_keepAlive_result()
  }

}



fileprivate final class AppToServer_deactivate_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: AppToServer_deactivate_args, rhs: AppToServer_deactivate_args) -> Bool {
  return true
}

extension AppToServer_deactivate_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension AppToServer_deactivate_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "AppToServer_deactivate_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_deactivate_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_deactivate_args()
  }

}



fileprivate final class AppToServer_deactivate_result {

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(ouch: AppException?) {
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_deactivate_result, rhs: AppToServer_deactivate_result) -> Bool {
  return
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_deactivate_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_deactivate_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_deactivate_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_deactivate_result {
    _ = try proto.readStructBegin()
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_deactivate_result(ouch: ouch)
  }

}



fileprivate final class AppToServer_requestActivationCode_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: AppToServer_requestActivationCode_args, rhs: AppToServer_requestActivationCode_args) -> Bool {
  return true
}

extension AppToServer_requestActivationCode_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension AppToServer_requestActivationCode_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "AppToServer_requestActivationCode_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_requestActivationCode_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_requestActivationCode_args()
  }

}



fileprivate final class AppToServer_requestActivationCode_result {

  fileprivate var success: RequestActivationCodeResponse?

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(success: RequestActivationCodeResponse?, ouch: AppException?) {
    self.success = success
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_requestActivationCode_result, rhs: AppToServer_requestActivationCode_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_requestActivationCode_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_requestActivationCode_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_requestActivationCode_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_requestActivationCode_result {
    _ = try proto.readStructBegin()
    var success: RequestActivationCodeResponse?
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try RequestActivationCodeResponse.read(from: proto)
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_requestActivationCode_result(success: success, ouch: ouch)
  }

}



fileprivate final class AppToServer_verifyPassword_args {

  fileprivate var encPassword: Data


  fileprivate init(encPassword: Data) {
    self.encPassword = encPassword
  }

}

fileprivate func ==(lhs: AppToServer_verifyPassword_args, rhs: AppToServer_verifyPassword_args) -> Bool {
  return
    (lhs.encPassword == rhs.encPassword)
}

extension AppToServer_verifyPassword_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (encPassword.hashValue)
    return result
  }

}

extension AppToServer_verifyPassword_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["encPassword": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_verifyPassword_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_verifyPassword_args {
    _ = try proto.readStructBegin()
    var encPassword: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .string):           encPassword = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(encPassword, named: "encPassword")

    return AppToServer_verifyPassword_args(encPassword: encPassword)
  }

}



fileprivate final class AppToServer_verifyPassword_result {

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(ouch: AppException?) {
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_verifyPassword_result, rhs: AppToServer_verifyPassword_result) -> Bool {
  return
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_verifyPassword_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_verifyPassword_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_verifyPassword_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_verifyPassword_result {
    _ = try proto.readStructBegin()
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_verifyPassword_result(ouch: ouch)
  }

}



fileprivate final class AppToServer_authenticateUser_args {

  fileprivate var authUserParam: AuthUserParam


  fileprivate init(authUserParam: AuthUserParam) {
    self.authUserParam = authUserParam
  }

}

fileprivate func ==(lhs: AppToServer_authenticateUser_args, rhs: AppToServer_authenticateUser_args) -> Bool {
  return
    (lhs.authUserParam == rhs.authUserParam)
}

extension AppToServer_authenticateUser_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (authUserParam.hashValue)
    return result
  }

}

extension AppToServer_authenticateUser_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["authUserParam": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_authenticateUser_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_authenticateUser_args {
    _ = try proto.readStructBegin()
    var authUserParam: AuthUserParam!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           authUserParam = try AuthUserParam.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(authUserParam, named: "authUserParam")

    return AppToServer_authenticateUser_args(authUserParam: authUserParam)
  }

}



fileprivate final class AppToServer_authenticateUser_result {

  fileprivate var success: AuthUserResponse?

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(success: AuthUserResponse?, ouch: AppException?) {
    self.success = success
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_authenticateUser_result, rhs: AppToServer_authenticateUser_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_authenticateUser_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_authenticateUser_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_authenticateUser_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_authenticateUser_result {
    _ = try proto.readStructBegin()
    var success: AuthUserResponse?
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try AuthUserResponse.read(from: proto)
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_authenticateUser_result(success: success, ouch: ouch)
  }

}



fileprivate final class AppToServer_getAuthenticationMethods_args {

  fileprivate var authSelectParam: AuthSelectParam


  fileprivate init(authSelectParam: AuthSelectParam) {
    self.authSelectParam = authSelectParam
  }

}

fileprivate func ==(lhs: AppToServer_getAuthenticationMethods_args, rhs: AppToServer_getAuthenticationMethods_args) -> Bool {
  return
    (lhs.authSelectParam == rhs.authSelectParam)
}

extension AppToServer_getAuthenticationMethods_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (authSelectParam.hashValue)
    return result
  }

}

extension AppToServer_getAuthenticationMethods_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["authSelectParam": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_getAuthenticationMethods_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_getAuthenticationMethods_args {
    _ = try proto.readStructBegin()
    var authSelectParam: AuthSelectParam!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           authSelectParam = try AuthSelectParam.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(authSelectParam, named: "authSelectParam")

    return AppToServer_getAuthenticationMethods_args(authSelectParam: authSelectParam)
  }

}



fileprivate final class AppToServer_getAuthenticationMethods_result {

  fileprivate var success: AuthSelectResponse?

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(success: AuthSelectResponse?, ouch: AppException?) {
    self.success = success
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_getAuthenticationMethods_result, rhs: AppToServer_getAuthenticationMethods_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_getAuthenticationMethods_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_getAuthenticationMethods_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_getAuthenticationMethods_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_getAuthenticationMethods_result {
    _ = try proto.readStructBegin()
    var success: AuthSelectResponse?
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .struct):           success = try AuthSelectResponse.read(from: proto)
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_getAuthenticationMethods_result(success: success, ouch: ouch)
  }

}



fileprivate final class AppToServer_getDeviceOfflineKeys_args {


  fileprivate init() { }
}

fileprivate func ==(lhs: AppToServer_getDeviceOfflineKeys_args, rhs: AppToServer_getDeviceOfflineKeys_args) -> Bool {
  return true
}

extension AppToServer_getDeviceOfflineKeys_args : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension AppToServer_getDeviceOfflineKeys_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "AppToServer_getDeviceOfflineKeys_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_getDeviceOfflineKeys_args {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_getDeviceOfflineKeys_args()
  }

}



fileprivate final class AppToServer_getDeviceOfflineKeys_result {

  fileprivate var success: TList<DeviceOfflineKey>?

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(success: TList<DeviceOfflineKey>?, ouch: AppException?) {
    self.success = success
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_getDeviceOfflineKeys_result, rhs: AppToServer_getDeviceOfflineKeys_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_getDeviceOfflineKeys_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_getDeviceOfflineKeys_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_getDeviceOfflineKeys_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_getDeviceOfflineKeys_result {
    _ = try proto.readStructBegin()
    var success: TList<DeviceOfflineKey>?
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .list):            success = try TList<DeviceOfflineKey>.read(from: proto)
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_getDeviceOfflineKeys_result(success: success, ouch: ouch)
  }

}



fileprivate final class AppToServer_authConnect_args {

  fileprivate var authUserParam: AuthConnectParam


  fileprivate init(authUserParam: AuthConnectParam) {
    self.authUserParam = authUserParam
  }

}

fileprivate func ==(lhs: AppToServer_authConnect_args, rhs: AppToServer_authConnect_args) -> Bool {
  return
    (lhs.authUserParam == rhs.authUserParam)
}

extension AppToServer_authConnect_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (authUserParam.hashValue)
    return result
  }

}

extension AppToServer_authConnect_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["authUserParam": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_authConnect_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_authConnect_args {
    _ = try proto.readStructBegin()
    var authUserParam: AuthConnectParam!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .struct):           authUserParam = try AuthConnectParam.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(authUserParam, named: "authUserParam")

    return AppToServer_authConnect_args(authUserParam: authUserParam)
  }

}



fileprivate final class AppToServer_authConnect_result {

  fileprivate var success: Int32?

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(success: Int32?, ouch: AppException?) {
    self.success = success
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_authConnect_result, rhs: AppToServer_authConnect_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_authConnect_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_authConnect_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_authConnect_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_authConnect_result {
    _ = try proto.readStructBegin()
    var success: Int32?
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .i32):             success = try Int32.read(from: proto)
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_authConnect_result(success: success, ouch: ouch)
  }

}



fileprivate final class AppToServer_proxyData_args {

  fileprivate var handle: Int64

  fileprivate var data: Data


  fileprivate init(handle: Int64, data: Data) {
    self.handle = handle
    self.data = data
  }

}

fileprivate func ==(lhs: AppToServer_proxyData_args, rhs: AppToServer_proxyData_args) -> Bool {
  return
    (lhs.handle == rhs.handle) &&
    (lhs.data == rhs.data)
}

extension AppToServer_proxyData_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (handle.hashValue)
    result = prime &* result &+ (data.hashValue)
    return result
  }

}

extension AppToServer_proxyData_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["handle": 1, "data": 2, ]
  }

  fileprivate static var structName: String { return "AppToServer_proxyData_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_proxyData_args {
    _ = try proto.readStructBegin()
    var handle: Int64!
    var data: Data!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i64):             handle = try Int64.read(from: proto)
        case (2, .string):           data = try Data.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(handle, named: "handle")
    try proto.validateValue(data, named: "data")

    return AppToServer_proxyData_args(handle: handle, data: data)
  }

}



fileprivate final class AppToServer_proxyData_result {

  fileprivate var success: Data?

  fileprivate var ouch: AppException?


  fileprivate init() { }
  fileprivate init(success: Data?, ouch: AppException?) {
    self.success = success
    self.ouch = ouch
  }

}

fileprivate func ==(lhs: AppToServer_proxyData_result, rhs: AppToServer_proxyData_result) -> Bool {
  return
    (lhs.success == rhs.success) &&
    (lhs.ouch == rhs.ouch)
}

extension AppToServer_proxyData_result : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (success?.hashValue ?? 0)
    result = prime &* result &+ (ouch?.hashValue ?? 0)
    return result
  }

}

extension AppToServer_proxyData_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["success": 0, "ouch": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_proxyData_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_proxyData_result {
    _ = try proto.readStructBegin()
    var success: Data?
    var ouch: AppException?

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (0, .string):           success = try Data.read(from: proto)
        case (1, .struct):           ouch = try AppException.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_proxyData_result(success: success, ouch: ouch)
  }

}



fileprivate final class AppToServer_proxyClose_args {

  fileprivate var handle: Int64


  fileprivate init(handle: Int64) {
    self.handle = handle
  }

}

fileprivate func ==(lhs: AppToServer_proxyClose_args, rhs: AppToServer_proxyClose_args) -> Bool {
  return
    (lhs.handle == rhs.handle)
}

extension AppToServer_proxyClose_args : Hashable {

  fileprivate var hashValue : Int {
    let prime = 31
    var result = 1
    result = prime &* result &+ (handle.hashValue)
    return result
  }

}

extension AppToServer_proxyClose_args : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return ["handle": 1, ]
  }

  fileprivate static var structName: String { return "AppToServer_proxyClose_args" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_proxyClose_args {
    _ = try proto.readStructBegin()
    var handle: Int64!

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case (1, .i64):             handle = try Int64.read(from: proto)
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()
    // Required fields
    try proto.validateValue(handle, named: "handle")

    return AppToServer_proxyClose_args(handle: handle)
  }

}



fileprivate final class AppToServer_proxyClose_result {


  fileprivate init() { }
}

fileprivate func ==(lhs: AppToServer_proxyClose_result, rhs: AppToServer_proxyClose_result) -> Bool {
  return true
}

extension AppToServer_proxyClose_result : Hashable {

  fileprivate var hashValue : Int {
    return 31
  }

}

extension AppToServer_proxyClose_result : TStruct {

  fileprivate static var fieldIds: [String: Int32] {
    return [:]
  }

  fileprivate static var structName: String { return "AppToServer_proxyClose_result" }

  fileprivate static func read(from proto: TProtocol) throws -> AppToServer_proxyClose_result {
    _ = try proto.readStructBegin()

    fields: while true {

      let (_, fieldType, fieldID) = try proto.readFieldBegin()

      switch (fieldID, fieldType) {
        case (_, .stop):            break fields
        case let (_, unknownType):  try proto.skip(type: unknownType)
      }

      try proto.readFieldEnd()
    }

    try proto.readStructEnd()

    return AppToServer_proxyClose_result()
  }

}



extension AppToServerClient : AppToServer {

  private func send_serverSignature(serverSignatureParam: ServerSignatureParam) throws {
    try outProtocol.writeMessageBegin(name: "serverSignature", type: .call, sequenceID: 0)
    let args = AppToServer_serverSignature_args(serverSignatureParam: serverSignatureParam)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_serverSignature() throws -> ServerSignatureResponse {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_serverSignature_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let ouch = result.ouch {
      throw ouch
    }
    throw TApplicationError(error: .missingResult(methodName: "serverSignature"))
  }

  public func serverSignature(serverSignatureParam: ServerSignatureParam) throws -> ServerSignatureResponse {
    try send_serverSignature(serverSignatureParam: serverSignatureParam)
    try outProtocol.transport.flush()
    return try recv_serverSignature()
  }

  private func send_getDomainSdkConfig(domainSdkConfigParam: DomainSdkConfigParam) throws {
    try outProtocol.writeMessageBegin(name: "getDomainSdkConfig", type: .call, sequenceID: 0)
    let args = AppToServer_getDomainSdkConfig_args(domainSdkConfigParam: domainSdkConfigParam)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getDomainSdkConfig() throws -> DomainSdkConfigResponse {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_getDomainSdkConfig_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let ouch = result.ouch {
      throw ouch
    }
    throw TApplicationError(error: .missingResult(methodName: "getDomainSdkConfig"))
  }

  public func getDomainSdkConfig(domainSdkConfigParam: DomainSdkConfigParam) throws -> DomainSdkConfigResponse {
    try send_getDomainSdkConfig(domainSdkConfigParam: domainSdkConfigParam)
    try outProtocol.transport.flush()
    return try recv_getDomainSdkConfig()
  }

  private func send_registerDispatcher(registerDispatcherParam: RegisterDispatcherParam) throws {
    try outProtocol.writeMessageBegin(name: "registerDispatcher", type: .call, sequenceID: 0)
    let args = AppToServer_registerDispatcher_args(registerDispatcherParam: registerDispatcherParam)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_registerDispatcher() throws -> RegisterDispatcherResponse {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_registerDispatcher_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let ouch = result.ouch {
      throw ouch
    }
    throw TApplicationError(error: .missingResult(methodName: "registerDispatcher"))
  }

  public func registerDispatcher(registerDispatcherParam: RegisterDispatcherParam) throws -> RegisterDispatcherResponse {
    try send_registerDispatcher(registerDispatcherParam: registerDispatcherParam)
    try outProtocol.transport.flush()
    return try recv_registerDispatcher()
  }

  private func send_activation(activationParam: ActivationParam) throws {
    try outProtocol.writeMessageBegin(name: "activation", type: .call, sequenceID: 0)
    let args = AppToServer_activation_args(activationParam: activationParam)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_activation() throws -> ActivationResponse {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_activation_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let ouch = result.ouch {
      throw ouch
    }
    throw TApplicationError(error: .missingResult(methodName: "activation"))
  }

  public func activation(activationParam: ActivationParam) throws -> ActivationResponse {
    try send_activation(activationParam: activationParam)
    try outProtocol.transport.flush()
    return try recv_activation()
  }

  private func send_login(loginParam: LoginParam) throws {
    try outProtocol.writeMessageBegin(name: "login", type: .call, sequenceID: 0)
    let args = AppToServer_login_args(loginParam: loginParam)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_login() throws -> LoginResponse {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_login_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let ouch = result.ouch {
      throw ouch
    }
    throw TApplicationError(error: .missingResult(methodName: "login"))
  }

  public func login(loginParam: LoginParam) throws -> LoginResponse {
    try send_login(loginParam: loginParam)
    try outProtocol.transport.flush()
    return try recv_login()
  }

  private func send_clientSignature(signaturenParam: SignatureParam) throws {
    try outProtocol.writeMessageBegin(name: "clientSignature", type: .call, sequenceID: 0)
    let args = AppToServer_clientSignature_args(signaturenParam: signaturenParam)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_clientSignature() throws -> SignatureResponse {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_clientSignature_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let ouch = result.ouch {
      throw ouch
    }
    throw TApplicationError(error: .missingResult(methodName: "clientSignature"))
  }

  public func clientSignature(signaturenParam: SignatureParam) throws -> SignatureResponse {
    try send_clientSignature(signaturenParam: signaturenParam)
    try outProtocol.transport.flush()
    return try recv_clientSignature()
  }

  private func send_getTemplateFromId(id: Int32) throws {
    try outProtocol.writeMessageBegin(name: "getTemplateFromId", type: .call, sequenceID: 0)
    let args = AppToServer_getTemplateFromId_args(id: id)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getTemplateFromId() throws -> Template {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_getTemplateFromId_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let ouch = result.ouch {
      throw ouch
    }
    throw TApplicationError(error: .missingResult(methodName: "getTemplateFromId"))
  }

  public func getTemplateFromId(id: Int32) throws -> Template {
    try send_getTemplateFromId(id: id)
    try outProtocol.transport.flush()
    return try recv_getTemplateFromId()
  }

  private func send_sendMessage(appMessage: AppMessage) throws {
    try outProtocol.writeMessageBegin(name: "sendMessage", type: .call, sequenceID: 0)
    let args = AppToServer_sendMessage_args(appMessage: appMessage)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendMessage() throws -> Bool {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_sendMessage_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let ouch = result.ouch {
      throw ouch
    }
    throw TApplicationError(error: .missingResult(methodName: "sendMessage"))
  }

  public func sendMessage(appMessage: AppMessage) throws -> Bool {
    try send_sendMessage(appMessage: appMessage)
    try outProtocol.transport.flush()
    return try recv_sendMessage()
  }

  private func send_sendMessageResponse(appMessageResponse: AppMessageResponse) throws {
    try outProtocol.writeMessageBegin(name: "sendMessageResponse", type: .call, sequenceID: 0)
    let args = AppToServer_sendMessageResponse_args(appMessageResponse: appMessageResponse)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendMessageResponse() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_sendMessageResponse_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let ouch = result.ouch {
      throw ouch
    }
  }

  public func sendMessageResponse(appMessageResponse: AppMessageResponse) throws {
    try send_sendMessageResponse(appMessageResponse: appMessageResponse)
    try outProtocol.transport.flush()
    try recv_sendMessageResponse()
  }

  private func send_sendLoginQrCode(data: String) throws {
    try outProtocol.writeMessageBegin(name: "sendLoginQrCode", type: .call, sequenceID: 0)
    let args = AppToServer_sendLoginQrCode_args(data: data)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_sendLoginQrCode() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_sendLoginQrCode_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let ouch = result.ouch {
      throw ouch
    }
  }

  public func sendLoginQrCode(data: String) throws {
    try send_sendLoginQrCode(data: data)
    try outProtocol.transport.flush()
    try recv_sendLoginQrCode()
  }

  private func send_getLoginQrCode(operatorId: String, sessionId: String) throws {
    try outProtocol.writeMessageBegin(name: "getLoginQrCode", type: .call, sequenceID: 0)
    let args = AppToServer_getLoginQrCode_args(operatorId: operatorId, sessionId: sessionId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getLoginQrCode() throws -> QrCodeResponse {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_getLoginQrCode_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let ouch = result.ouch {
      throw ouch
    }
    throw TApplicationError(error: .missingResult(methodName: "getLoginQrCode"))
  }

  public func getLoginQrCode(operatorId: String, sessionId: String) throws -> QrCodeResponse {
    try send_getLoginQrCode(operatorId: operatorId, sessionId: sessionId)
    try outProtocol.transport.flush()
    return try recv_getLoginQrCode()
  }

  private func send_changePassword(encPassword: Data, newEncPassword: Data) throws {
    try outProtocol.writeMessageBegin(name: "changePassword", type: .call, sequenceID: 0)
    let args = AppToServer_changePassword_args(encPassword: encPassword, newEncPassword: newEncPassword)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_changePassword() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_changePassword_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let ouch = result.ouch {
      throw ouch
    }
  }

  public func changePassword(encPassword: Data, newEncPassword: Data) throws {
    try send_changePassword(encPassword: encPassword, newEncPassword: newEncPassword)
    try outProtocol.transport.flush()
    try recv_changePassword()
  }

  private func send_getCloudSafe(uniqueKey: SdkCloudSafeKey, userLoginId: String) throws {
    try outProtocol.writeMessageBegin(name: "getCloudSafe", type: .call, sequenceID: 0)
    let args = AppToServer_getCloudSafe_args(uniqueKey: uniqueKey, userLoginId: userLoginId)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getCloudSafe() throws -> SdkCloudSafe {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_getCloudSafe_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let ouch = result.ouch {
      throw ouch
    }
    throw TApplicationError(error: .missingResult(methodName: "getCloudSafe"))
  }

  public func getCloudSafe(uniqueKey: SdkCloudSafeKey, userLoginId: String) throws -> SdkCloudSafe {
    try send_getCloudSafe(uniqueKey: uniqueKey, userLoginId: userLoginId)
    try outProtocol.transport.flush()
    return try recv_getCloudSafe()
  }

  private func send_setCloudSafe(sdkCloudSafe: SdkCloudSafe) throws {
    try outProtocol.writeMessageBegin(name: "setCloudSafe", type: .call, sequenceID: 0)
    let args = AppToServer_setCloudSafe_args(sdkCloudSafe: sdkCloudSafe)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_setCloudSafe() throws -> Int64 {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_setCloudSafe_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let ouch = result.ouch {
      throw ouch
    }
    throw TApplicationError(error: .missingResult(methodName: "setCloudSafe"))
  }

  public func setCloudSafe(sdkCloudSafe: SdkCloudSafe) throws -> Int64 {
    try send_setCloudSafe(sdkCloudSafe: sdkCloudSafe)
    try outProtocol.transport.flush()
    return try recv_setCloudSafe()
  }

  private func send_getCloudSafeList(nameFilter: String, includeShare: Bool, modifiedFromEpoch: Int64, owner: CloudSafeOwner) throws {
    try outProtocol.writeMessageBegin(name: "getCloudSafeList", type: .call, sequenceID: 0)
    let args = AppToServer_getCloudSafeList_args(nameFilter: nameFilter, includeShare: includeShare, modifiedFromEpoch: modifiedFromEpoch, owner: owner)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getCloudSafeList() throws -> TList<SdkCloudSafe> {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_getCloudSafeList_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let ouch = result.ouch {
      throw ouch
    }
    throw TApplicationError(error: .missingResult(methodName: "getCloudSafeList"))
  }

  public func getCloudSafeList(nameFilter: String, includeShare: Bool, modifiedFromEpoch: Int64, owner: CloudSafeOwner) throws -> TList<SdkCloudSafe> {
    try send_getCloudSafeList(nameFilter: nameFilter, includeShare: includeShare, modifiedFromEpoch: modifiedFromEpoch, owner: owner)
    try outProtocol.transport.flush()
    return try recv_getCloudSafeList()
  }

  private func send_disconnect(appErrorCodes: AppErrorCodes, message: String) throws {
    try outProtocol.writeMessageBegin(name: "disconnect", type: .call, sequenceID: 0)
    let args = AppToServer_disconnect_args(appErrorCodes: appErrorCodes, message: message)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_disconnect() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try AppToServer_disconnect_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func disconnect(appErrorCodes: AppErrorCodes, message: String) throws {
    try send_disconnect(appErrorCodes: appErrorCodes, message: message)
    try outProtocol.transport.flush()
    try recv_disconnect()
  }

  private func send_keepAlive() throws {
    try outProtocol.writeMessageBegin(name: "keepAlive", type: .call, sequenceID: 0)
    let args = AppToServer_keepAlive_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_keepAlive() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try AppToServer_keepAlive_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func keepAlive() throws {
    try send_keepAlive()
    try outProtocol.transport.flush()
    try recv_keepAlive()
  }

  private func send_deactivate() throws {
    try outProtocol.writeMessageBegin(name: "deactivate", type: .call, sequenceID: 0)
    let args = AppToServer_deactivate_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_deactivate() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_deactivate_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let ouch = result.ouch {
      throw ouch
    }
  }

  public func deactivate() throws {
    try send_deactivate()
    try outProtocol.transport.flush()
    try recv_deactivate()
  }

  private func send_requestActivationCode() throws {
    try outProtocol.writeMessageBegin(name: "requestActivationCode", type: .call, sequenceID: 0)
    let args = AppToServer_requestActivationCode_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_requestActivationCode() throws -> RequestActivationCodeResponse {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_requestActivationCode_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let ouch = result.ouch {
      throw ouch
    }
    throw TApplicationError(error: .missingResult(methodName: "requestActivationCode"))
  }

  public func requestActivationCode() throws -> RequestActivationCodeResponse {
    try send_requestActivationCode()
    try outProtocol.transport.flush()
    return try recv_requestActivationCode()
  }

  private func send_verifyPassword(encPassword: Data) throws {
    try outProtocol.writeMessageBegin(name: "verifyPassword", type: .call, sequenceID: 0)
    let args = AppToServer_verifyPassword_args(encPassword: encPassword)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_verifyPassword() throws {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_verifyPassword_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let ouch = result.ouch {
      throw ouch
    }
  }

  public func verifyPassword(encPassword: Data) throws {
    try send_verifyPassword(encPassword: encPassword)
    try outProtocol.transport.flush()
    try recv_verifyPassword()
  }

  private func send_authenticateUser(authUserParam: AuthUserParam) throws {
    try outProtocol.writeMessageBegin(name: "authenticateUser", type: .call, sequenceID: 0)
    let args = AppToServer_authenticateUser_args(authUserParam: authUserParam)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_authenticateUser() throws -> AuthUserResponse {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_authenticateUser_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let ouch = result.ouch {
      throw ouch
    }
    throw TApplicationError(error: .missingResult(methodName: "authenticateUser"))
  }

  public func authenticateUser(authUserParam: AuthUserParam) throws -> AuthUserResponse {
    try send_authenticateUser(authUserParam: authUserParam)
    try outProtocol.transport.flush()
    return try recv_authenticateUser()
  }

  private func send_getAuthenticationMethods(authSelectParam: AuthSelectParam) throws {
    try outProtocol.writeMessageBegin(name: "getAuthenticationMethods", type: .call, sequenceID: 0)
    let args = AppToServer_getAuthenticationMethods_args(authSelectParam: authSelectParam)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getAuthenticationMethods() throws -> AuthSelectResponse {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_getAuthenticationMethods_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let ouch = result.ouch {
      throw ouch
    }
    throw TApplicationError(error: .missingResult(methodName: "getAuthenticationMethods"))
  }

  public func getAuthenticationMethods(authSelectParam: AuthSelectParam) throws -> AuthSelectResponse {
    try send_getAuthenticationMethods(authSelectParam: authSelectParam)
    try outProtocol.transport.flush()
    return try recv_getAuthenticationMethods()
  }

  private func send_getDeviceOfflineKeys() throws {
    try outProtocol.writeMessageBegin(name: "getDeviceOfflineKeys", type: .call, sequenceID: 0)
    let args = AppToServer_getDeviceOfflineKeys_args()
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_getDeviceOfflineKeys() throws -> TList<DeviceOfflineKey> {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_getDeviceOfflineKeys_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let ouch = result.ouch {
      throw ouch
    }
    throw TApplicationError(error: .missingResult(methodName: "getDeviceOfflineKeys"))
  }

  public func getDeviceOfflineKeys() throws -> TList<DeviceOfflineKey> {
    try send_getDeviceOfflineKeys()
    try outProtocol.transport.flush()
    return try recv_getDeviceOfflineKeys()
  }

  private func send_authConnect(authUserParam: AuthConnectParam) throws {
    try outProtocol.writeMessageBegin(name: "authConnect", type: .call, sequenceID: 0)
    let args = AppToServer_authConnect_args(authUserParam: authUserParam)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_authConnect() throws -> Int32 {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_authConnect_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let ouch = result.ouch {
      throw ouch
    }
    throw TApplicationError(error: .missingResult(methodName: "authConnect"))
  }

  public func authConnect(authUserParam: AuthConnectParam) throws -> Int32 {
    try send_authConnect(authUserParam: authUserParam)
    try outProtocol.transport.flush()
    return try recv_authConnect()
  }

  private func send_proxyData(handle: Int64, data: Data) throws {
    try outProtocol.writeMessageBegin(name: "proxyData", type: .call, sequenceID: 0)
    let args = AppToServer_proxyData_args(handle: handle, data: data)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_proxyData() throws -> Data {
    try inProtocol.readResultMessageBegin() 
    let result = try AppToServer_proxyData_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

    if let success = result.success {
      return success
    }
    if let ouch = result.ouch {
      throw ouch
    }
    throw TApplicationError(error: .missingResult(methodName: "proxyData"))
  }

  public func proxyData(handle: Int64, data: Data) throws -> Data {
    try send_proxyData(handle: handle, data: data)
    try outProtocol.transport.flush()
    return try recv_proxyData()
  }

  private func send_proxyClose(handle: Int64) throws {
    try outProtocol.writeMessageBegin(name: "proxyClose", type: .call, sequenceID: 0)
    let args = AppToServer_proxyClose_args(handle: handle)
    try args.write(to: outProtocol)
    try outProtocol.writeMessageEnd()
  }

  private func recv_proxyClose() throws {
    try inProtocol.readResultMessageBegin() 
    _ = try AppToServer_proxyClose_result.read(from: inProtocol)
    try inProtocol.readMessageEnd()

  }

  public func proxyClose(handle: Int64) throws {
    try send_proxyClose(handle: handle)
    try outProtocol.transport.flush()
    try recv_proxyClose()
  }

}

extension AppToServerProcessor : TProcessor {

  static let processorHandlers: ProcessorHandlerDictionary = {

    var processorHandlers = ProcessorHandlerDictionary()

    processorHandlers["serverSignature"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_serverSignature_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_serverSignature_result()
      do {
        result.success = try handler.serverSignature(serverSignatureParam: args.serverSignatureParam)
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "serverSignature", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getDomainSdkConfig"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_getDomainSdkConfig_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_getDomainSdkConfig_result()
      do {
        result.success = try handler.getDomainSdkConfig(domainSdkConfigParam: args.domainSdkConfigParam)
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getDomainSdkConfig", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["registerDispatcher"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_registerDispatcher_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_registerDispatcher_result()
      do {
        result.success = try handler.registerDispatcher(registerDispatcherParam: args.registerDispatcherParam)
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "registerDispatcher", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["activation"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_activation_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_activation_result()
      do {
        result.success = try handler.activation(activationParam: args.activationParam)
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "activation", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["login"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_login_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_login_result()
      do {
        result.success = try handler.login(loginParam: args.loginParam)
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "login", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["clientSignature"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_clientSignature_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_clientSignature_result()
      do {
        result.success = try handler.clientSignature(signaturenParam: args.signaturenParam)
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "clientSignature", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getTemplateFromId"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_getTemplateFromId_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_getTemplateFromId_result()
      do {
        result.success = try handler.getTemplateFromId(id: args.id)
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getTemplateFromId", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendMessage"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_sendMessage_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_sendMessage_result()
      do {
        result.success = try handler.sendMessage(appMessage: args.appMessage)
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendMessage", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendMessageResponse"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_sendMessageResponse_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_sendMessageResponse_result()
      do {
        try handler.sendMessageResponse(appMessageResponse: args.appMessageResponse)
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendMessageResponse", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["sendLoginQrCode"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_sendLoginQrCode_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_sendLoginQrCode_result()
      do {
        try handler.sendLoginQrCode(data: args.data)
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "sendLoginQrCode", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getLoginQrCode"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_getLoginQrCode_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_getLoginQrCode_result()
      do {
        result.success = try handler.getLoginQrCode(operatorId: args.operatorId, sessionId: args.sessionId)
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getLoginQrCode", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["changePassword"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_changePassword_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_changePassword_result()
      do {
        try handler.changePassword(encPassword: args.encPassword, newEncPassword: args.newEncPassword)
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "changePassword", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getCloudSafe"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_getCloudSafe_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_getCloudSafe_result()
      do {
        result.success = try handler.getCloudSafe(uniqueKey: args.uniqueKey, userLoginId: args.userLoginId)
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getCloudSafe", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["setCloudSafe"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_setCloudSafe_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_setCloudSafe_result()
      do {
        result.success = try handler.setCloudSafe(sdkCloudSafe: args.sdkCloudSafe)
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "setCloudSafe", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getCloudSafeList"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_getCloudSafeList_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_getCloudSafeList_result()
      do {
        result.success = try handler.getCloudSafeList(nameFilter: args.nameFilter, includeShare: args.includeShare, modifiedFromEpoch: args.modifiedFromEpoch, owner: args.owner)
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getCloudSafeList", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["disconnect"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_disconnect_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_disconnect_result()
      do {
        try handler.disconnect(appErrorCodes: args.appErrorCodes, message: args.message)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "disconnect", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["keepAlive"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_keepAlive_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_keepAlive_result()
      do {
        try handler.keepAlive()
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "keepAlive", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["deactivate"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_deactivate_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_deactivate_result()
      do {
        try handler.deactivate()
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "deactivate", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["requestActivationCode"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_requestActivationCode_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_requestActivationCode_result()
      do {
        result.success = try handler.requestActivationCode()
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "requestActivationCode", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["verifyPassword"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_verifyPassword_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_verifyPassword_result()
      do {
        try handler.verifyPassword(encPassword: args.encPassword)
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "verifyPassword", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["authenticateUser"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_authenticateUser_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_authenticateUser_result()
      do {
        result.success = try handler.authenticateUser(authUserParam: args.authUserParam)
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "authenticateUser", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getAuthenticationMethods"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_getAuthenticationMethods_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_getAuthenticationMethods_result()
      do {
        result.success = try handler.getAuthenticationMethods(authSelectParam: args.authSelectParam)
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getAuthenticationMethods", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["getDeviceOfflineKeys"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_getDeviceOfflineKeys_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_getDeviceOfflineKeys_result()
      do {
        result.success = try handler.getDeviceOfflineKeys()
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "getDeviceOfflineKeys", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["authConnect"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_authConnect_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_authConnect_result()
      do {
        result.success = try handler.authConnect(authUserParam: args.authUserParam)
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "authConnect", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["proxyData"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_proxyData_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_proxyData_result()
      do {
        result.success = try handler.proxyData(handle: args.handle, data: args.data)
      }
      catch let error as AppException { result.ouch = error }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "proxyData", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    processorHandlers["proxyClose"] = { sequenceID, inProtocol, outProtocol, handler in

      let args = try AppToServer_proxyClose_args.read(from: inProtocol)

      try inProtocol.readMessageEnd()

      var result = AppToServer_proxyClose_result()
      do {
        try handler.proxyClose(handle: args.handle)
      }
      catch let error { throw error }

      try outProtocol.writeMessageBegin(name: "proxyClose", type: .reply, sequenceID: sequenceID)
      try result.write(to: outProtocol)
      try outProtocol.writeMessageEnd()
    }
    return processorHandlers
  }()

  public func process(on inProtocol: TProtocol, outProtocol: TProtocol) throws {

    let (messageName, _, sequenceID) = try inProtocol.readMessageBegin()

    if let processorHandler = AppToServerProcessor.processorHandlers[messageName] {
      do {
        try processorHandler(sequenceID, inProtocol, outProtocol, service)
      }
      catch let error as TApplicationError {
        try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: error)
      }
    }
    else {
      try inProtocol.skip(type: .struct)
      try inProtocol.readMessageEnd()
      let ex = TApplicationError(error: .unknownMethod(methodName: messageName))
      try outProtocol.writeException(messageName: messageName, sequenceID: sequenceID, ex: ex)
    }
  }
}

